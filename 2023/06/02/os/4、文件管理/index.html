<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="何必要叹气呢？" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="何必要叹气呢？" type="application/atom+xml"><link rel="alternate" type="application/json" title="何必要叹气呢？" href="https://www.htired.top/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.11"><link rel="modulepreload" href="/js/chunk-6AROBX2M.js"></link><link rel="modulepreload" href="/js/chunk-CDFWGKAZ.js"></link><link rel="modulepreload" href="/js/chunk-NGTPZFEZ.js"></link><link rel="modulepreload" href="/js/chunk-T5KHDXD7.js"></link><link rel="modulepreload" href="/js/chunk-UCNSAKJE.js"></link><link rel="modulepreload" href="/js/chunk-WIQECBEN.js"></link><link rel="modulepreload" href="/js/comments-YMZC2DEK.js"></link><link rel="modulepreload" href="/js/copy-tex-5ZQCB5LC.js"></link><link rel="modulepreload" href="/js/index.esm-UQTDDMFT.js"></link><link rel="modulepreload" href="/js/post-GXBO3POO.js"></link><link rel="modulepreload" href="/js/quicklink-Q3LCUN34.js"></link><link rel="modulepreload" href="/js/search-HYBAVWN7.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="modulepreload" href="/js/waline-2AUA5EA7.js"></link><link rel="stylesheet" href="/css/comments-SJZAII77.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="stylesheet" href="/css/siteInit.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="stylesheet" href="/css/waline-ZFRMIHOE.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/6c1bc1deb312449195a8c6a802e916c1.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/t1.png?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/81d1da7e1ba142629967fea196c73e0e.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://raw.githubusercontent.com/htired/MyPic/main/img/1b87e2c5880511ebb6edd017c2d2eca2.png" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/4fc551ee880a11ebb6edd017c2d2eca2.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/792a4b6934fc491b81342206e3192e59.png?raw=true" as="image" fetchpriority="high"><meta name="description" content="送君南浦，伤如之何？"/><link rel="canonical" href="https://www.htired.top/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"><title>4、文件管理</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">4、文件管理</h1><div class="meta"><span class="item" title="创建时间：2023-06-02 15:59:56"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-06-02T15:59:56+08:00">2023-06-02</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>46k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>42 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Htired Love</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/6c1bc1deb312449195a8c6a802e916c1.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/t1.png?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/81d1da7e1ba142629967fea196c73e0e.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://raw.githubusercontent.com/htired/MyPic/main/img/1b87e2c5880511ebb6edd017c2d2eca2.png&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/4fc551ee880a11ebb6edd017c2d2eca2.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/792a4b6934fc491b81342206e3192e59.png?raw=true&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/os/" itemprop="item" rel="index" title="分类于操作系统"><span itemprop="name">操作系统<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.htired.top/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="htired"/><meta itemprop="description" content="路还很长，这不是最终的结果, 送君南浦，伤如之何？"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="何必要叹气呢？"/></span><div class="body md" itemprop="articleBody"><h1 id="初识文件管理"><a class="anchor" href="#初识文件管理">#</a> 初识文件管理</h1>
<h2 id="回顾"><a class="anchor" href="#回顾">#</a> 回顾</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214212705943.png" alt="image-20230214212705943" /></p>
<p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件内部</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件内部</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件内部</span></span></span></span>的数据应该怎样组织起来？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件之间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件之间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件之间</span></span></span></span>又应该又应该怎么组织起来？</p>
<p>从下往上看， <code>OS</code>  应提供<strong>哪些功能</strong>，才能方便用户、应用程序使用文件？</p>
<p>从上往下看，文件数据应该怎么存放在外存（磁盘）上？</p>
<hr />
<h2 id="文件的属性"><a class="anchor" href="#文件的属性">#</a> 文件的属性</h2>
<p>一个文件有哪些属性？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件名</span></span></span></span>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>同一目录下不允许有重名文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}同一目录下不允许有重名文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">同一目录下不允许有重名文件</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214214136798.png" alt="image-20230214214136798" /></p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>标识符</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}标识符</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">标识符</span></span></span></span>：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于<strong>区分各个文件的一种内部名称</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>类型</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}类型</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">类型</span></span></span></span>：指明文件的类型</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214215656271.png" alt="image-20230214215656271" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>位置</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}位置</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">位置</span></span></span></span>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>大小</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}大小</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">大小</span></span></span></span>：指明文件大小</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>创建时间、上次修改时间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}创建时间、上次修改时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">创建时间、上次修改时间</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件所有者信息</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件所有者信息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件所有者信息</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>保护信息</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}保护信息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">保护信息</span></span></span></span>：对文件进行保护的访问控制信息</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214215937832.png" alt="image-20230214215937832" /></p>
<hr />
<h2 id="无结构文件有结构文件"><a class="anchor" href="#无结构文件有结构文件">#</a> 无结构文件 / 有结构文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214220215086.png" alt="image-20230214220215086" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214220412681.png" alt="image-20230214220412681" /></p>
<p>有结构文件中，各个记录间应该如何组织的问题―— 应该顺序存放？还是用索引表来表示记录间的顺序？――这是 “文件的逻辑结构” 重点要探讨的问题</p>
<hr />
<h2 id="文件之间应该怎样组织起来"><a class="anchor" href="#文件之间应该怎样组织起来">#</a> 文件之间应该怎样组织起来？</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214221924543.png" alt="image-20230214221924543" /></p>
<hr />
<h2 id="操作系统应该向上提供哪些功能"><a class="anchor" href="#操作系统应该向上提供哪些功能">#</a> 操作系统应该向上提供哪些功能？</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214222344882.png" alt="image-20230214222344882" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214222450989.png" alt="image-20230214222450989" /></p>
<p>读 / 写文件之前，需要 &quot;打开文件&quot;</p>
<p>读 / 写文件结束之后，需要 &quot;关闭文件&quot;</p>
<hr />
<p>可用几个基本操作完成更复杂的操作</p>
<ul>
<li>比如：“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li>
</ul>
<hr />
<p>操作系统在背后做的处理会在之后进行探讨</p>
<hr />
<h2 id="从上往下看文件应如何存放在外存"><a class="anchor" href="#从上往下看文件应如何存放在外存">#</a> 从上往下看，文件应如何存放在外存？</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214224432564.png" alt="image-20230214224432564" /></p>
<p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如 1 B）。</p>
<p>每个存储单元对应一个物理地址</p>
<hr />
<p>类似于内存分为一个个 “内存块” ，外存会分为一个个 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>块</mtext><mi mathvariant="normal">/</mi><mtext>磁盘块</mtext><mi mathvariant="normal">/</mi><mtext>物理块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}块/磁盘块/物理块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">块</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">磁盘块</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">物理块</span></span></span></span>” 。</p>
<p>每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址</p>
<ul>
<li>如本例中，一块包含 2&lt;sup&gt;10&lt;/sup&gt; 个地址，即 1 KB。</li>
</ul>
<p>同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小</p>
<hr />
<p>操作系统以 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">块</span></span></span></span>” 为单位为文件分配存储空间，因此即使一个文件大小只有 10 B，但它依然需要占用 1 KB 的磁盘块。外存中的数据读入内存时同样以块为单位</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214224545840.png" alt="image-20230214224545840" /></p>
<hr />
<h2 id="其他需要由操作系统实现的文件管理功能"><a class="anchor" href="#其他需要由操作系统实现的文件管理功能">#</a> 其他需要由操作系统实现的文件管理功能</h2>
<p>文件共享：使多个用户可以共享使用一个文件</p>
<p>文件保护：如何保证不同的用户对文件有不同的操作权限</p>
<h2 id="整体框架"><a class="anchor" href="#整体框架">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214224902792.png" alt="image-20230214224902792" /></p>
<hr />
<h1 id="文件的逻辑结构"><a class="anchor" href="#文件的逻辑结构">#</a> 文件的逻辑结构</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214225138140.png" alt="image-20230214225138140" /></p>
<p>所谓的 “逻辑结构”，就是指在<strong>用户</strong>看来，文件内部的数据应该是如何组织起来的。</p>
<p>而 “物理结构” 指的是在<strong>操作系统</strong>看来，文件的数据是如何存放在外存中的。</p>
<p>类似于数据结构的 “逻辑结构” 和 “物理结构”。</p>
<p>如 “线性表” 就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列</p>
<ul>
<li>如: a，b，c，d，e ......</li>
</ul>
<p>“线性表” 这种逻辑结构可以用不同的物理结构实现，</p>
<p>如：顺序表 / 链表。</p>
<ul>
<li>
<p>顺序表的各个元素在逻辑上相邻，在物理上也相邻；</p>
</li>
<li>
<p>而链表的各个元素在物理上可以是不相邻的。</p>
</li>
<li>
<p>因此，顺序表可以实现 “随机访问” ，而 “链表” 无法实现随机访问。</p>
</li>
</ul>
<p>可见，算法的具体实现与逻辑结构、物理结构都有关</p>
<ul>
<li>文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关</li>
</ul>
<h2 id="无结构文件流式文件"><a class="anchor" href="#无结构文件流式文件">#</a> 无结构文件（流式文件）</h2>
<p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>无结构文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}无结构文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">无结构文件</span></span></span></span>：文件内部的数据就是一系列二进制流或字符流组成。又称 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>流式文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}流式文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">流式文件</span></span></span></span>”。</p>
<ul>
<li>如：Windows 操作系统中的 .txt 文件。</li>
</ul>
<p>文件内部的数据其实就是一系列字符流，没有明显的结构特性。</p>
<p>因此也不用探讨无结构文件的 “逻辑结构 &quot; 问题。</p>
<h2 id="有结构文件"><a class="anchor" href="#有结构文件">#</a> 有结构文件</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>有结构文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}有结构文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">有结构文件</span></span></span></span>：由一组相似的记录组成，又称 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>记录式文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}记录式文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">记录式文件</span></span></span></span>”。每条记录又若干个数据项组成。</p>
<p>如：数据库表文件。一般来说，每条记录有一个数据项可作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>关键字</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}关键字</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">关键字</span></span></span></span>（作为识别不同记录的  <code>ID</code> )</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214225826746.png" alt="image-20230214225826746" /></p>
<hr />
<p>根据各条记录的长度（占用存储空间）是否相等，可分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>定长记录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}定长记录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">定长记录</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可变长记录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可变长记录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可变长记录</span></span></span></span>两种</p>
<ul>
<li>例如： <code>mysql</code>  中的  <code>varchar</code>  和  <code>char</code></li>
</ul>
<p>例如：<strong>定长记录</strong></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214230019585.png" alt="image-20230214230019585" /></p>
<p>例如：<strong>可变长记录</strong></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214230132021.png" alt="image-20230214230132021" /></p>
<h3 id="顺序文件"><a class="anchor" href="#顺序文件">#</a> 顺序文件</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>顺序文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}顺序文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">顺序文件</span></span></span></span>：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>定长的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}定长的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">定长的</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可变长的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可变长的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可变长的</span></span></span></span>。各个记录在物理上可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>顺序存储</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}顺序存储</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">顺序存储</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链式存储</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链式存储</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链式存储</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214230417152.png" alt="image-20230214230417152" /></p>
<p>假设：已经知道了文件的起始地址（也就是第一个记录存放的位置）</p>
<p>思考 1：能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）</p>
<p>思考 2：能否快速找到某个关键字对应的记录存放的位置？</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214231253316.png" alt="image-20230214231253316" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214231312328.png" alt="image-20230214231312328" /></p>
<hr />
<p><strong>结论</strong>：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p>
<p><strong>注</strong>：一般来说，考试题目中所说的 “顺序文件” 指的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理上顺序存储的顺序文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理上顺序存储的顺序文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理上顺序存储的顺序文件</span></span></span></span>。之后的讲解中提到的顺序文件也默认如此。</p>
<p>可见，顺序文件的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>增加</mtext><mi mathvariant="normal">/</mi><mtext>删除一个记录比较困难</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}增加/删除一个记录比较困难</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">增加</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">删除一个记录比较困难</span></span></span></span>（如果是串结构则相对简单）</p>
<hr />
<p>在实际应用当中，为了减少磁盘的  <code>I/O</code>  次数，一般操作系统会管理日志文件，用这个日志文件记录对各个文件修改的信息，每隔一段较长的时间，再把这些信息统一的合并到外存当中的文件数据当中</p>
<hr />
<h3 id="索引文件"><a class="anchor" href="#索引文件">#</a> 索引文件</h3>
<p>对于可变长记录文件，要找到第  <code>i</code>  个记录，必须先顺序第查找前  <code>i - 1</code>  个记录但是很多应用场景中又必须使用可变长记录。如何解决这个问题？</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214232236190.png" alt="image-20230214232236190" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引表</span></span></span></span>本身是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>定长记录的顺序文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}定长记录的顺序文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">定长记录的顺序文件</span></span></span></span>。因此可以快速找到第  <code>i</code>  个记录对应的索引项。</p>
<p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p>
<p>每当要增加 / 删除一个记录时，需要对索引表进行修改。</p>
<p>由于索引文件有很快的检索速度，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>主要用于对信息处理的及时性要求比较高的场合</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}主要用于对信息处理的及时性要求比较高的场合</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">主要用于对信息处理的及时性要求比较高的场合</span></span></span></span>。</p>
<hr />
<p>另外，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可以用不同的数据项建立多个索引表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可以用不同的数据项建立多个索引表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可以用不同的数据项建立多个索引表</span></span></span></span>。</p>
<p>如：学生信息表中，可用关键字 “学号” 建立一张索引表。也可用 “姓名” 建立一张索引表。这样就可以根据 “姓名” 快速地检索文件了。<br />
（Eg： <code>SQL</code>  就支持根据某个数据项建立索引的功能）</p>
<hr />
<h3 id="索引顺序文件"><a class="anchor" href="#索引顺序文件">#</a> 索引顺序文件</h3>
<p>思考索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。</p>
<p>比如：文件的每个记录平均只占 8 B，而每个索引表项占 32 个字节，那么索引表都要比文件内容本身大 4 倍，</p>
<ul>
<li>这样对存储空间的利用率就太低了。</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214232841197.png" alt="image-20230214232841197" /></p>
<p>例如：<strong>分块查找</strong>。组间有序，组内无序</p>
<p>用这种策略确实可以让索引表 “瘦身”，但是是否会出现不定长记录的顺序文件检索速度慢的问题呢？</p>
<hr />
<h3 id="索引顺序文件检索效率分析"><a class="anchor" href="#索引顺序文件检索效率分析">#</a> 索引顺序文件（检索效率分析）</h3>
<p>若一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>顺序文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}顺序文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">顺序文件</span></span></span></span>有 10000 个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>平均须查找</mtext><mn>5000</mn><mtext>个记录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}平均须查找 5000 个记录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">平均须查找</span><span class="mord" style="color:red;">5000</span><span class="mord cjk_fallback" style="color:red;">个记录</span></span></span></span>。</p>
<ul>
<li>(1 + 2 + 3 + ...... + n) / (n + 1) ：设每次再任意位置找到记录的概率相同</li>
</ul>
<p>若采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引顺序文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引顺序文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引顺序文件</span></span></span></span>结构，可把 10000 个记录分为 √10000 = 100 组，每组 100 个记录。</p>
<p>则需要先顺序查找索引表找到分组（共 100 个分组，因此索引表长度为 100 ，平均需要查 50 次)，找到分组后，再在分组中顺序查找记录（每个分组 100 个记录，因此平均需要查 50 次）。</p>
<p>可见，采用索引顺序文件结构后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>平均查找次数减少为</mtext><mn>50</mn><mo>+</mo><mn>50</mn><mo>=</mo><mn>100</mn><mtext>次</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}平均查找次数减少为 50 + 50 = 100 次</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback" style="color:red;">平均查找次数减少为</span><span class="mord" style="color:red;">50</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord" style="color:red;">50</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">100</span><span class="mord cjk_fallback" style="color:red;">次</span></span></span></span>。</p>
<p><strong>可以理解为查字典，先查目录找到相应的位置范围，再位置范围内查找</strong></p>
<hr />
<p>同理，若文件共有 10&lt;sup&gt;6&lt;/sup &gt; 个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录平均需要查找 500 + 500 = 1000 次。这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>查找次数依然很多</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}查找次数依然很多</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">查找次数依然很多</span></span></span></span>，如何解决呢？</p>
<h3 id="多级索引顺序文件"><a class="anchor" href="#多级索引顺序文件">#</a> 多级索引顺序文件</h3>
<p>为了进一步提高检索效率，可以为顺序文件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>建立多级索引表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}建立多级索引表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">建立多级索引表</span></span></span></span>。例如，对于一个含 10&lt;sup&gt;6&lt;/sup&gt; 个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即 10000 个定长记录），再把这 10000 个定长记录分组，每组 100 个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214234602146.png" alt="image-20230214234602146" /></p>
<p>例如：<strong>B+ 树</strong></p>
<h2 id="整体框架-2"><a class="anchor" href="#整体框架-2">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214234740083.png" alt="image-20230214234740083" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215000157163.png" alt="image-20230215000157163" /></p>
<h1 id="文件目录"><a class="anchor" href="#文件目录">#</a> 文件目录</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215213908469.png" alt="image-20230215213908469" /></p>
<p>这种目录结构对于用户来说有什么好处？</p>
<p>文件之间的组织结构清晰，易于查找</p>
<p>编程时也可以很方便的用文件路径找到一个文件</p>
<p>从操作系统的角度来看，这些目录应该是如何实现的？</p>
<hr />
<p>就是我们很熟悉的 Windows 操作系统的 &quot;文件夹&quot;</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215214235812.png" alt="image-20230215214235812" /></p>
<hr />
<h2 id="文件控制块"><a class="anchor" href="#文件控制块">#</a> 文件控制块</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215214411194.png" alt="image-20230215214411194" /></p>
<p>目录本身就是一种有结构的文件，由一条条记录组成。每一条记录对应一个放在该目录下的文件</p>
<hr />
<p>当我们双击 “照片” 后，操作系统会在这个目录表中找到关键字 “照片” 对应的<strong>目录项</strong>（也就是记录)，</p>
<ul>
<li>然后从外存中将 “照片” 目录的信息读入内存，于是，“照片” 目录中的内容就可以显示出来了。</li>
</ul>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215215236856.png" alt="image-20230215215236856" /></p>
<p><code>FCB</code>  的有序集合称为 “<strong>文件目录</strong>”，一个  <code>FCB</code>  就是一个文件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>目录项</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}目录项</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">目录项</span></span></span></span>。</p>
<p><code>FCB</code>  中包含了文件的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>基本信息</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}基本信息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">基本信息</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件名</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理地址</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理地址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理地址</span></span></span></span>、逻辑结构、物理结构等），存取控制信息（是否可读 / 可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>最重要</mtext><mo separator="true">,</mo><mtext>最基本的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}最重要, 最基本的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">最重要</span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback" style="color:red;">最基本的</span></span></span></span>还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件名、文件存放的物理地址</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red} 文件名、文件存放的物理地址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件名、文件存放的物理地址</span></span></span></span></p>
<p><code>FCB</code>  实现了文件名和文件之间的映射。使用户（用户程序）可以实现 “按名存取”</p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>目录文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}目录文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">目录文件</span></span></span></span>：是文件目录以文件的形式保存在外存中的文件</p>
<hr />
<h2 id="需要对目录进行哪些操作"><a class="anchor" href="#需要对目录进行哪些操作">#</a> 需要对目录进行哪些操作？</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>搜索</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}搜索</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">搜索</span></span></span></span>：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>创建文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}创建文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">创建文件</span></span></span></span>：创建一个新文件时，需要在其所属的目录中增加一个目录项</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>删除文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}删除文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">删除文件</span></span></span></span>：当删除一个文件时，需要在目录中删除相应的目录项</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>显示目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}显示目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">显示目录</span></span></span></span>：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>修改目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}修改目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">修改目录</span></span></span></span>：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项</p>
<ul>
<li>如：文件重命名</li>
</ul>
<hr />
<h2 id="单级目录结构"><a class="anchor" href="#单级目录结构">#</a> 单级目录结构</h2>
<p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215220016430.png" alt="image-20230215220016430" /></p>
<p>单级目录实现了 &quot;按名存取&quot;，但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不允许文件重名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不允许文件重名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不允许文件重名</span></span></span></span></p>
<p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项（ <code>FCB</code> ）插入目录表中。</p>
<p>显然，<strong>单级目录结构不适用于多用户操作系统</strong></p>
<ul>
<li>怎么可能让多个用户共享一个目录</li>
</ul>
<hr />
<h2 id="两级目录结构"><a class="anchor" href="#两级目录结构">#</a> 两级目录结构</h2>
<p>早期的多用户操作系统，采用两级目录结构。分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>主文件目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}主文件目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">主文件目录</span></span></span></span>（MFD，Master File Directory）和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>用户文件目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}用户文件目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">用户文件目录</span></span></span></span>（UFD，User Flie Directory) 。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215220439627.png" alt="image-20230215220439627" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>允许不同用户的文件重名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}允许不同用户的文件重名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">允许不同用户的文件重名</span></span></span></span>文件民虽然相同，但是对应的其实是不同的文件</p>
<p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。</p>
<p>但是两级目录结构依然缺乏灵活性，<strong>用户不能对自己的文件进行分类。</strong></p>
<hr />
<h2 id="多级目录结构"><a class="anchor" href="#多级目录结构">#</a> 多级目录结构</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215220632638.png" alt="image-20230215220632638" /></p>
<p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。</p>
<p>各级目录之间用 “/” 隔开。从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>根目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}根目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">根目录</span></span></span></span>出发的路径称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>绝对路径</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}绝对路径</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">绝对路径</span></span></span></span>。</p>
<p>例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>自拍</mtext><mi mathvariant="normal">.</mi><mi>j</mi><mi>p</mi><mi>g</mi><mtext>的绝对路径是</mtext><mi mathvariant="normal">&quot;</mi><mtext>照片</mtext><mi mathvariant="normal">/</mi><mn>2015</mn><mo>−</mo><mn>08</mn><mi mathvariant="normal">/</mi><mtext>自拍</mtext><mi mathvariant="normal">.</mi><mi>j</mi><mi>p</mi><mi>g</mi><mi mathvariant="normal">&quot;</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}自拍.jpg 的绝对路径是 &quot;照片/2015-08/自拍.jpg&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">自拍</span><span class="mord" style="color:red;">.</span><span class="mord mathnormal" style="margin-right:0.05724em;color:red;">j</span><span class="mord mathnormal" style="color:red;">p</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord cjk_fallback" style="color:red;">的绝对路径是</span><span class="mord" style="color:red;">&quot;</span><span class="mord cjk_fallback" style="color:red;">照片</span><span class="mord" style="color:red;">/2015</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">08/</span><span class="mord cjk_fallback" style="color:red;">自拍</span><span class="mord" style="color:red;">.</span><span class="mord mathnormal" style="margin-right:0.05724em;color:red;">j</span><span class="mord mathnormal" style="color:red;">p</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord" style="color:red;">&quot;</span></span></span></span></p>
<p>系统根据绝对路径一层一层地找到下一级目录。</p>
<ul>
<li>刚开<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>始从外存读入根目录的目录表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}始从外存读入根目录的目录表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">始从外存读入根目录的目录表</span></span></span></span>；找到 “照片” 目录的存放位置后，从外存读入对应的目录表；</li>
<li>再找到 “2015-08” 目录的存放位置，再从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>外存读入对应目录表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}外存读入对应目录表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">外存读入对应目录表</span></span></span></span>；</li>
<li>最后才找到文件 “自拍.jpg” 的存放位置。</li>
<li>整个过程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>需要</mtext><mn>3</mn><mtext>次读磁盘</mtext><mi>l</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>操作</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}需要 3 次读磁盘 l/O操作</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">需要</span><span class="mord" style="color:red;">3</span><span class="mord cjk_fallback" style="color:red;">次读磁盘</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">操作</span></span></span></span>。</li>
</ul>
<hr />
<p>很多时候，用户会连续访问同一目录内的多个文件</p>
<ul>
<li>比如：接连查看 “2015-08&quot; 目录内的多个照片文件</li>
</ul>
<p>显然，每次都从根目录开始查找，是很低效的。因此可以设置一个 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>当前目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}当前目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">当前目录</span></span></span></span>”。</p>
<p>例如，此时已经打开了 “照片” 的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>从当前目录出发</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}从当前目录出发</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">从当前目录出发</span></span></span></span>的 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>相对路径</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}相对路径</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">相对路径</span></span></span></span>”。</p>
<p>可见，引入 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>当前目录</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}当前目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">当前目录</span></span></span></span>” 和 &quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>相对路径</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}相对路径</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">相对路径</span></span></span></span> &quot; 后，磁盘  <code>I/O</code>  的次数减少了。这就提升了访问文件的效率。</p>
<ul>
<li>只需要从当前目录开始，而不需要重新从根目录开始查询</li>
</ul>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>树形目录结构</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}树形目录结构</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">树形目录结构</span></span></span></span>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。</p>
<p>但是，树形结构<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不便于实现文件的共享</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不便于实现文件的共享</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不便于实现文件的共享</span></span></span></span>。为此，提出了 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>无环图目录结构</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}无环图目录结构</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">无环图目录结构</span></span></span></span>”。</p>
<hr />
<h2 id="无环图目录结构"><a class="anchor" href="#无环图目录结构">#</a> 无环图目录结构</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215221629488.png" alt="image-20230215221629488" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可以用不同的文件名指向同一个文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可以用不同的文件名指向同一个文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可以用不同的文件名指向同一个文件</span></span></span></span>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p>
<p>需要为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>每个共享结点设置一个共享计数器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}每个共享结点设置一个共享计数器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">每个共享结点设置一个共享计数器</span></span></span></span>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的  <code>FCB</code> 、并使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>共享计数器减</mtext><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\color{red}共享计数器减 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">共享计数器减</span><span class="mord" style="color:red;">1</span></span></span></span>，并不会直接删除共享结点。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>只有共享计数器减为</mtext><mn>0</mn><mtext>时，才删除节点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}只有共享计数器减为 0 时，才删除节点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">只有共享计数器减为</span><span class="mord" style="color:red;">0</span><span class="mord cjk_fallback" style="color:red;">时，才删除节点</span></span></span></span></p>
<p>注意：共享文件不同于复制文件。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</span></span></span></span></p>
<p>其实就是：硬链接</p>
<h2 id="索引节点fcb-的改进"><a class="anchor" href="#索引节点fcb-的改进">#</a> 索引节点（FCB 的改进）</h2>
<p>按照文件名搜索文件时，并不需要关心其他信息。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215222242849.png" alt="image-20230215222242849" /></p>
<p>思考有何好处？</p>
<p>假设一个  <code>FCB</code>  是 64 B，磁盘块的大小为 1 KB，则每个盘块中只能存放 16 个  <code>FCB</code> 。若一个文件目录中共有 640 个目录项，则共需要占用 640 / 16 = 40 个盘块。因此按照某文件名检索该目录，平均需要查询 320 个目录项，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>平均需要启动磁盘</mtext><mn>20</mn><mtext>次（每次磁盘</mtext><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>读入一块）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}平均需要启动磁盘 20 次（每次磁盘 I/O 读入一块）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">平均需要启动磁盘</span><span class="mord" style="color:red;">20</span><span class="mord cjk_fallback" style="color:red;">次（每次磁盘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">读入一块）</span></span></span></span>。</p>
<p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>使用索引结点机制</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}使用索引结点机制</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">使用索引结点机制</span></span></span></span>，文件名占 14 B，索引结点指针占 2 B，则每个盘块可存放 64 个目录项，那么按文件名检索目录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>平均只需要读入</mtext><mn>320</mn><mi mathvariant="normal">/</mi><mn>64</mn><mo>=</mo><mn>5</mn><mtext>个磁盘块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}平均只需要读入 320 / 64 = 5 个磁盘块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">平均只需要读入</span><span class="mord" style="color:red;">320/64</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord" style="color:red;">5</span><span class="mord cjk_fallback" style="color:red;">个磁盘块</span></span></span></span>。显然，这<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>将大大提升文件检索速度</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}将大大提升文件检索速度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">将大大提升文件检索速度</span></span></span></span></p>
<hr />
<p>其实就是索引节点指针大小小，相应的该文件目录项也就小，一个磁盘块可以放更多的文件目录项</p>
<hr />
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据 “存放位置” 即可找到文件。</p>
<p>存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在外存中</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在外存中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在外存中</span></span></span></span>的索引结点称为 “ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>磁盘索引结点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}磁盘索引结点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">磁盘索引结点</span></span></span></span>”，当索引结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>放入内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}放入内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">放入内存</span></span></span></span>后称为 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>内存索引结点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}内存索引结点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">内存索引结点</span></span></span></span>”。</p>
<p>相比之下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>内存索引结点中需要增加一些信息</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}内存索引结点中需要增加一些信息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">内存索引结点中需要增加一些信息</span></span></span></span></p>
<ul>
<li>比如：文件是否被修改、此时有几个进程正在访问该文件等。</li>
</ul>
<h2 id="整体框架-3"><a class="anchor" href="#整体框架-3">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215224148337.png" alt="image-20230215224148337" /></p>
<h1 id="文件的物理结构文件分配方式对非空闲磁盘块的管理"><a class="anchor" href="#文件的物理结构文件分配方式对非空闲磁盘块的管理">#</a> 文件的物理结构（文件分配方式）（对非空闲磁盘块的管理）</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215224413734.png" alt="image-20230215224413734" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215224750754.png" alt="image-20230215224750754" /></p>
<h2 id="文件块-磁盘块"><a class="anchor" href="#文件块-磁盘块">#</a> 文件块、磁盘块</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230214224432564.png" alt="image-20230214224432564" /></p>
<p>类似于内存分页，磁盘中的存储单元也会被分为一个个 “块 / 磁盘块 / 物理块”。</p>
<p>很多操作系统中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>磁盘块的大小与内存块、页面的大小相同</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}磁盘块的大小与内存块、页面的大小相同</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">磁盘块的大小与内存块、页面的大小相同</span></span></span></span></p>
<ul>
<li>内存与外存进行数据交换的时候会很方便</li>
</ul>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215225041343.png" alt="image-20230215225041343" /></p>
<hr />
<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>
<p>同样的，在外存管理中，为了方便对文件数据的管理，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件的逻辑地址空间也被分为了一个一个的文件“块”</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件的逻辑地址空间也被分为了一个一个的文件“块”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">文件的逻辑地址空间也被分为了一个一个的文件</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">块</span><span class="mord" style="color:red;">”</span></span></span></span>。</p>
<p>于是文件的<strong>逻辑地址</strong>也可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>（逻辑块号，块内地址）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}（逻辑块号，块内地址）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">（逻辑块号，块内地址）</span></span></span></span>的形式。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215231655726.png" alt="image-20230215231655726" /></p>
<h2 id="连续分配"><a class="anchor" href="#连续分配">#</a> 连续分配</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>连续分配</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}连续分配</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">连续分配</span></span></span></span>方式要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>每个文件在磁盘上占有一组连续的块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}每个文件在磁盘上占有一组连续的块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">每个文件在磁盘上占有一组连续的块</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215231749444.png" alt="image-20230215231749444" /></p>
<p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？</p>
<p><strong>（逻辑块号，块内地址）→（物理块号，块内地址）</strong>。</p>
<p>只需转换块号就行，块内地址保持不变</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215231855805.png" alt="image-20230215231855805" /></p>
<p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（ <code>FCB</code> ）</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理块号</mtext><mo>=</mo><mtext>起始块号＋逻辑块号</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理块号 = 起始块号＋逻辑块号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理块号</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">起始块号＋逻辑块号</span></span></span></span></p>
<ul>
<li>例如：访问文件 &quot;aaa&quot; 的逻辑块号为 2 的物理地址：4（起始块号）+ 2（逻辑块号）</li>
</ul>
<p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度就不合法）</p>
<p>可以直接算出逻辑块号对应的物理块号，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>连续分配支持顺序访问和直接访问（即随机访问）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}连续分配支持顺序访问和直接访问（即随机访问）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">连续分配支持顺序访问和直接访问（即随机访问）</span></span></span></span></p>
<ul>
<li>顺序访问：若访问逻辑块号 2，则必须先访问逻辑块号 0 和 1</li>
<li>直接访问：若访问逻辑块号 2，则没有必要先访问逻辑块号 0 和 1，可以直接访问逻辑块号 2</li>
</ul>
<hr />
<h3 id="优点"><a class="anchor" href="#优点">#</a> 优点</h3>
<p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215232639822.png" alt="image-20230215232639822" /></p>
<ul>
<li>若读取紫色的磁盘块，需要读取之间其他不需要的磁盘块</li>
</ul>
<p>结论：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>连续分配的文件在顺序读</mtext><mi mathvariant="normal">/</mi><mtext>写时速度最快</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}连续分配的文件在顺序读/写时速度最快</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">连续分配的文件在顺序读</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">写时速度最快</span></span></span></span></p>
<hr />
<h3 id="缺点"><a class="anchor" href="#缺点">#</a> 缺点</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215232905817.png" alt="image-20230215232905817" /></p>
<p>若此时文件  <code>A</code>  要拓展，需要再增加一个磁盘块（总共需要连续的 4 个磁盘块）。</p>
<p>由于采用连续结构，因此文件 A 占用的磁盘块必须是连续的。</p>
<p>因此只能将文件  <code>A</code>  <strong>全部 “迁移”</strong> 到绿色区域。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215233014346.png" alt="image-20230215233014346" /></p>
<p>结论：物理上采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>连续分配的文件不方便拓展</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}连续分配的文件不方便拓展</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">连续分配的文件不方便拓展</span></span></span></span></p>
<ul>
<li>类比于在数组中插入一个数据，要么后面的数据右移，要么当前连续的数据移到其中空闲的区域</li>
</ul>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215233227126.png" alt="image-20230215233227126" /></p>
<p>结论：物理上采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</span></span></span></span></p>
<p>可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>紧凑</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}紧凑</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">紧凑</span></span></span></span>来处理碎片，但是需要耗费很大的时间代价。</p>
<ul>
<li>因为剩余空闲的磁盘块离散的存放，而导致当前连续的文件无法为其分配连续的足够的存储空间</li>
</ul>
<hr />
<h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>优点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}优点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">优点</span></span></span></span>：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p>
<hr />
<h2 id="链接分配"><a class="anchor" href="#链接分配">#</a> 链接分配</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链接分配</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链接分配</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链接分配</span></span></span></span>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>隐式链接</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}隐式链接</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">隐式链接</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>显式链接</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}显式链接</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">显式链接</span></span></span></span>两种。</p>
<h3 id="隐式链接"><a class="anchor" href="#隐式链接">#</a> 隐式链接</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215233847050.png" alt="image-20230215233847050" /></p>
<h4 id="如何实现文件的逻辑块号到物理块号的转变"><a class="anchor" href="#如何实现文件的逻辑块号到物理块号的转变">#</a> 如何实现文件的逻辑块号到物理块号的转变？</h4>
<p>从目录项中找到起始块号（即 0 号块），将 0 号逻辑块读入内存，由此知道 1 号逻辑块存放的物理块号，于是读入 1 号逻辑块，再找到 2 号逻辑块的存放位置....… 以此类推。</p>
<p>因此，读入  <code>i</code>  号逻辑块，总共需要  <code>i +1</code>  次磁盘  <code>l/O</code>  。</p>
<hr />
<p>结论：采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链式分配（隐式链接）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链式分配（隐式链接）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链式分配（隐式链接）</span></span></span></span>方式的文件，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>只支持顺序访问，不支持随机访问</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}只支持顺序访问，不支持随机访问</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">只支持顺序访问，不支持随机访问</span></span></span></span>，查找效率低。</p>
<ul>
<li>只有知道了前一个逻辑块号的物理地址，才知道当前逻辑块号（由前面一个逻辑块推出来）</li>
</ul>
<p>另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<hr />
<p><strong>是否方便拓展文件？</strong></p>
<ul>
<li>只需随便在磁盘中找到一个空闲的块，并将其挂到链尾即可</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215234508572.png" alt="image-20230215234508572" /></p>
<hr />
<p>结论：采用隐式链接的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链接分配方式，很方便文件拓展</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链接分配方式，很方便文件拓展</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链接分配方式，很方便文件拓展</span></span></span></span>。</p>
<p>另外，所有的空闲磁盘块都可以被利用，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不会有碎片问题，外存利用率高</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不会有碎片问题，外存利用率高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不会有碎片问题，外存利用率高</span></span></span></span>。</p>
<hr />
<h4 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>隐式链接</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}隐式链接</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">隐式链接</span></span></span></span>――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>优点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}优点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">优点</span></span></span></span>：很方便文件拓展，不会有碎片问题，外存利用率高。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<hr />
<h3 id="显示链接fat"><a class="anchor" href="#显示链接fat">#</a> 显示链接（FAT）</h3>
<p><strong>把用于链接文件各物理块的指针显式地存放在一张表中</strong>。即文件分配表（ <code>FAT</code> ，File Allocation Table)</p>
<ul>
<li>例如：数组模拟链表（静态链表）</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215235043754.png" alt="image-20230215235043754" /></p>
<p>假设某个新创建的文件 “aaa” 依次存放在磁盘块 2 -&gt; 5 -&gt; 0 -&gt; 1</p>
<p>假设某个新创建的文件 “bbb” 依次存放在磁盘块 4 -&gt; 23 -&gt; 3</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：一个磁盘仅设置一张</mtext><mi>F</mi><mi>A</mi><mi>T</mi><mtext>。开机时，将</mtext><mi>F</mi><mi>A</mi><mi>T</mi><mtext>读入内存，并常驻内存。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注意：一个磁盘仅设置一张 FAT。开机时，将 FAT 读入内存，并常驻内存。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：一个磁盘仅设置一张</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">F</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">。开机时，将</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">F</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">读入内存，并常驻内存。</span></span></span></span></p>
<p><code>FAT</code>  的各个表项在物理上<strong>连续存储</strong>，且<strong>每一个表项长度相同</strong>，因此 “物理块号” 字段可以是隐含的。</p>
<hr />
<h4 id="如何实现文件的逻辑块号到物理块号的转变-2"><a class="anchor" href="#如何实现文件的逻辑块号到物理块号的转变-2">#</a> 如何实现文件的逻辑块号到物理块号的转变？</h4>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230215235448330.png" alt="image-20230215235448330" /></p>
<p>用户给出要访问的逻辑块号  <code>i</code> ，操作系统找到该文件对应的目录项（ <code>FCB</code> ） ...</p>
<p>从目录项中找到起始块号，若  <code>i &gt; 0</code> ，则查询内存中的文件分配表  <code>FAT</code> ，往后找到  <code>i</code>  号逻辑块对应的物理块号。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑块号转换成物理块号的过程不需要读磁盘操作</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑块号转换成物理块号的过程不需要读磁盘操作</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑块号转换成物理块号的过程不需要读磁盘操作</span></span></span></span>。</p>
<ul>
<li>例：若用户想要访问一个文件 &quot;aaa&quot; 的 2 号逻辑块。操作系统首先找到文件 &quot;aaa&quot; 的 0 号逻辑块存放的物理块号是 2，操作系统查询文件分配表，0 号逻辑块下一个逻辑块（1 号逻辑块的）应该是存放在 5 号物理块当中的。1 号逻辑块的下一逻辑块（2 号逻辑块）存放在 0 号物理块当中。于是就知道用户想要访问的 2 号逻辑块存放的物理块号了</li>
</ul>
<hr />
<p>结论：采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链式分配（显式链接）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链式分配（显式链接）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链式分配（显式链接）</span></span></span></span>方式的文件，支持顺序访问，也<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>支持随机访问（想访问</mtext><mi>i</mi><mtext>号逻辑块时，并不需要依次访问之前的</mtext><mn>0</mn><mtext> </mtext><mi>i</mi><mo>−</mo><mn>1</mn><mtext>号逻辑块</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}支持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i - 1号逻辑块)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback" style="color:red;">支持随机访问（想访问</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord cjk_fallback" style="color:red;">号逻辑块时，并不需要依次访问之前的</span><span class="mord" style="color:red;">0</span><span class="mspace nobreak" style="color:red;"><span style="color:red;"> </span></span><span class="mord mathnormal" style="color:red;">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">1</span><span class="mord cjk_fallback" style="color:red;">号逻辑块</span><span class="mclose" style="color:red;">)</span></span></span></span>，由于块号转换的过程<strong>不需要访问磁盘</strong>，因此相比于隐式链接来说，访问速度快很多。</p>
<ul>
<li><strong>对  <code>FAT</code>  表的顺序访问，来支持磁盘的随机访问</strong></li>
<li>对内存访问的速度与  <code>I/O</code>  访问的速度不是一个数量级的，内存中的访问  <code>FAT</code>  表操作默认不耗时间</li>
</ul>
<p>显然，显式链接<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>也不会产生外部碎片，也可以很方便地对文件进行拓展</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}也不会产生外部碎片，也可以很方便地对文件进行拓展</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">也不会产生外部碎片，也可以很方便地对文件进行拓展</span></span></span></span>。</p>
<ul>
<li>只需要在  <code>FAT</code>  表中添加下一物理块号即可</li>
</ul>
<hr />
<h4 id="总结-3"><a class="anchor" href="#总结-3">#</a> 总结</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>显式链接</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}显式链接</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">显式链接</span></span></span></span>――把用于链接文件各物理块的指针显式地存放在一张表中， 即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件分配表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件分配表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件分配表</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>F</mi><mi>A</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}FAT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">F</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span></span></span></span>， File Allocation Table）。</p>
<p><strong>一个磁盘只会建立一张文件分配表</strong>。开机时文件分配表放入内存，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>并常驻内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}并常驻内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">并常驻内存</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>优点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}优点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">优点</span></span></span></span>：很方便文件拓展，不会有碎片问题，外存利用率高，并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>支持随机访问</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}支持随机访问</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">支持随机访问</span></span></span></span>。</p>
<ul>
<li>相比于隐式链接来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>地址转换时不需要访问磁盘，因此文件的访问效率更高</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}地址转换时不需要访问磁盘，因此文件的访问效率更高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">地址转换时不需要访问磁盘，因此文件的访问效率更高</span></span></span></span>。</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：文件分配表的需要占用一定的存储空间。</p>
<hr />
<p>若遇到未指明隐式 / 显式的 “链接分配”，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>默认</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}默认</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">默认</span></span></span></span>指的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>隐式链接</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}隐式链接</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">隐式链接</span></span></span></span>的链接分配</p>
<h2 id="索引分配"><a class="anchor" href="#索引分配">#</a> 索引分配</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引分配</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引分配</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引分配</span></span></span></span>允许文件离散地分配在各个磁盘块中，系统会<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>为每个文件建立一张索引表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}为每个文件建立一张索引表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">为每个文件建立一张索引表</span></span></span></span>，索引表中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>记录了文件的各个逻辑块对应的物理块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}记录了文件的各个逻辑块对应的物理块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">记录了文件的各个逻辑块对应的物理块</span></span></span></span>（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。</p>
<p>索引表存放的磁盘块称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引块</span></span></span></span>。文件数据存放的磁盘块称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据块</span></span></span></span>。</p>
<hr />
<p>假设某个新创建的文件 “aaa” 的数据依次存放在磁盘块 2 → 5  → 13 → 9。</p>
<p>7 号磁盘块作为 “aaa” 的索引块，索引块中保存了索引表的内容。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216191003371.png" alt="image-20230216191003371" /></p>
<hr />
<p>注：在显式链接的链式分配方式中，文件分配表  <code>FAT</code>  是<strong>一个磁盘对应一张</strong>。</p>
<ul>
<li>而索引分配方式中，索引表是<strong>一个文件对应一张</strong>。</li>
</ul>
<p>可以用<strong>固定的长度</strong>表示物理块号</p>
<ul>
<li>
<p>如：假设磁盘总容量为 1 TB = 2&lt;sup&gt;40&lt;/sup&gt; B，磁盘块大小为 1 KB，则共有 2&lt;sup&gt;30&lt;/sup&gt; 个磁盘块，<strong>则可用 4 B 表示磁盘块号</strong></p>
</li>
<li>
<p>因此，索引表中的 “逻辑块号” 可以是隐含的。</p>
</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216191445006.png" alt="image-20230216191445006" /></p>
<hr />
<h3 id="如何实现文件的逻辑块号到物理块号的转变-3"><a class="anchor" href="#如何实现文件的逻辑块号到物理块号的转变-3">#</a> 如何实现文件的逻辑块号到物理块号的转变？</h3>
<p>用户给出要访问的逻辑块号  <code>i</code> ，操作系统找到该文件对应的目录项（ <code>FCB</code> ），从中找到这个文件对应的索引块的块号，再从这个索引块中读取这个文件的索引表的内容，然后通过逻辑块号  <code>i</code>  查询这个索引表得出该逻辑块号对应的物理块号即可</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216202529194.png" alt="image-20230216202529194" /></p>
<hr />
<p>可见，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引分配方式可以支持随机访问</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引分配方式可以支持随机访问</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引分配方式可以支持随机访问</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件拓展也很容易实现</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件拓展也很容易实现</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件拓展也很容易实现</span></span></span></span></p>
<ul>
<li>只需要给文件分配一个空闲块，并增加一个索引表项即可</li>
</ul>
<p>但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引表需要占用一定的存储空间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引表需要占用一定的存储空间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引表需要占用一定的存储空间</span></span></span></span></p>
<hr />
<p>若每个磁盘块 1 KB，一个索引表项 4 B，则一个磁盘块只能存放 256 个索引项。</p>
<p>如果一个文件的大小超过了 256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p>
<h3 id="链接方案"><a class="anchor" href="#链接方案">#</a> 链接方案</h3>
<p>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链接方案</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链接方案</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链接方案</span></span></span></span>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放</p>
<hr />
<p>若每个磁盘块 1 KB，一个索引表项 4 B，则一个磁盘块只能存放 256 个索引项。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216203339881.png" alt="image-20230216203339881" /></p>
<p>采用链接方案，文件的  <code>FCB</code>  只需要存放第一个索引块号</p>
<hr />
<p>假设磁盘块大小为 1 KB，一个索引表项占 4 B，则一个磁盘块只能存放 256 个索引项。</p>
<p>若一个文件大小为 256 * 256 KB = 65,536 KB= 64 MB</p>
<p>该文件共有 256 * 256（64 MB） 个块，也就对应 256 * 256 个索引项，也就需要 256 个索引块来存储这些索引块用链接方案连起来。</p>
<p>若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第 256 个索引块），而各个索引块之间是用指针链接起来的，<strong>因此必须先顺序地读入前 255 个索引块。</strong></p>
<p>这显然是很低效的。</p>
<hr />
<h3 id="多层索引"><a class="anchor" href="#多层索引">#</a> 多层索引</h3>
<p>② <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多层索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}多层索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多层索引</span></span></span></span>：建立多层索引（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>原理类似于多级页表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}原理类似于多级页表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">原理类似于多级页表</span></span></span></span>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216204106638.png" alt="image-20230216204106638" /></p>
<p>假设磁盘块大小为 1 KB，一个索引表项占 4 B，则一个磁盘块只能存放 256 个索引项。</p>
<p>若某文件采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>两层索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}两层索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">两层索引</span></span></span></span>，则该<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件的最大长度</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件的最大长度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件的最大长度</span></span></span></span>可以到 256 * 256 * 1 KB = 65,536 KB = 64 MB</p>
<hr />
<p>如：要访问 1026 号逻辑块，则 1026 / 256 = 4，1026 % 256 = 2</p>
<p>因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，再查询二级索引表的 2 号表项即可知道 1026 号逻辑块存放的磁盘块号了。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>访问目标数据块，需要</mtext><mn>3</mn><mtext>次磁盘</mtext><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}访问目标数据块，需要 3 次磁盘 I/O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">访问目标数据块，需要</span><span class="mord" style="color:red;">3</span><span class="mord cjk_fallback" style="color:red;">次磁盘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span></span></span></span>。</p>
<hr />
<p>若采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>三层索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}三层索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">三层索引</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件的最大长度</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件的最大长度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件的最大长度</span></span></span></span>为 256 * 256 * 256 * 1 KB =16 GB</p>
<hr />
<p>采用 K 层索引结构，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>&lt;</mo><mi>b</mi><mo>&gt;</mo><mtext>顶级索引表未调入内存</mtext><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}&lt;b&gt;顶级索引表未调入内存&lt;/b&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback" style="color:red;">顶级索引表未调入内存</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span></span></span></span>，则访问一个数据块只需要 K+1 次读磁盘操作</p>
<hr />
<h3 id="混合索引"><a class="anchor" href="#混合索引">#</a> 混合索引</h3>
<p>③ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>混合索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}混合索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">混合索引</span></span></span></span>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>直接地址索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}直接地址索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">直接地址索引</span></span></span></span>（直接指向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据块</span></span></span></span>），又包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>一级间接索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}一级间接索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">一级间接索引</span></span></span></span>（指向单层索引表)、还包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>两级间接索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}两级间接索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">两级间接索引</span></span></span></span>（指向两层索引表)。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216205011714.png" alt="image-20230216205011714" /></p>
<p>若顶级索引表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>还没读入内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}还没读入内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">还没读入内存</span></span></span></span></p>
<p>访问 0 ~ 7 号逻辑块：两次读磁盘</p>
<ul>
<li>根据  <code>FCB</code>  中的索引块号得出顶级索引表的物理地址，将顶级索引表读出内存后，根据相应的逻辑块号（0 ~ 7）读出目标数据块的物理块号</li>
</ul>
<p>访问 8 ~ 263：三次读磁盘</p>
<p>访问 264 ~ 65799：四次读磁盘</p>
<p><strong>对于小文件，只需较少的读磁盘次数就可以访问目标数据块</strong>。(一般计算机中小文件更多)</p>
<hr />
<h3 id="总结-4"><a class="anchor" href="#总结-4">#</a> 总结</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引分配</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引分配</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引分配</span></span></span></span>允许文件离散地分配在各个磁盘块中，系统会<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>为每个文件建立一张索引表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}为每个文件建立一张索引表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">为每个文件建立一张索引表</span></span></span></span>，索引表中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>记录了文件的各个逻辑块对应的物理块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}记录了文件的各个逻辑块对应的物理块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">记录了文件的各个逻辑块对应的物理块</span></span></span></span>（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。</p>
<p>索引表存放的磁盘块称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>索引块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}索引块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">索引块</span></span></span></span>。文件数据存放的磁盘块称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据块</span></span></span></span>。</p>
<p>若文件太大，索引表项太多，可以采取以下三种方法解决:</p>
<p>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链接方案</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链接方案</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链接方案</span></span></span></span>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到  <code>i</code>  号索引块，必须先依次读入 <code>0 ~ i - 1</code>  号索引块，这就导致磁盘  <code>l/O</code>  次数过多，查找效率低下。</li>
</ul>
<hr />
<p>② <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>多层索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}多层索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">多层索引</span></span></span></span>：建立多层索引（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>原理类似于多级页表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}原理类似于多级页表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">原理类似于多级页表</span></span></span></span>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>顶级索引表未调入内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}顶级索引表未调入内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">顶级索引表未调入内存</span></span></span></span>，则访问一个数据块只需要 K + 1 次读磁盘操作。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：即使是小文件，访问一个数据块依然需要 K + 1 次读磁盘。</li>
</ul>
<hr />
<p>③ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>混合索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}混合索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">混合索引</span></span></span></span>：多种索引分配方式的结合。例如，一个文伴的顶级索引表中，既包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>直接地址索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}直接地址索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">直接地址索引</span></span></span></span>（直接指向数据块），又包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>一级间接索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}一级间接索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">一级间接索引</span></span></span></span>（指向单层索引表)、还包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>两级间接索引</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}两级间接索引</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">两级间接索引</span></span></span></span>（指向两层索引表）。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>优点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}优点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">优点</span></span></span></span>：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</li>
</ul>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>&lt;</mo><mi>b</mi><mo>&gt;</mo><mtext>超级超级超级重要考点</mtext><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}&lt;b&gt;超级超级超级重要考点&lt;/b&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback" style="color:red;">超级超级超级重要考点</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span></span></span></span>：</p>
<ul>
<li>① 要会根据多层索引、混合索引的结构计算出文件的最大长度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>&lt;</mo><mi>b</mi><mo>&gt;</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}&lt;b&gt;Key&lt;/b&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">Key</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span></span></span></span>：各级索引表最大不能超过一个块）；</li>
<li>② 要能自己分析访问某个数据块所需要的读磁盘次数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>&lt;</mo><mi>b</mi><mo>&gt;</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>b</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}&lt;b&gt;Key&lt;/b&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">Key</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span></span></span></span>： <code>FCB</code>  中会存有指向顶级索引块的指针，因此可以根据  <code>FCB</code>  读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。</li>
<li>另外，要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意题目条件――顶级索引块是否已调入内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注意题目条件――顶级索引块是否已调入内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意题目条件</span><span class="mord" style="color:red;">――</span><span class="mord cjk_fallback" style="color:red;">顶级索引块是否已调入内存</span></span></span></span>）</li>
</ul>
<h2 id="总结-5"><a class="anchor" href="#总结-5">#</a> 总结</h2>
<p>&lt;table height=&quot;300&quot; width=&quot;300&quot; border=&quot;1&quot; &gt;<br />
&lt;thead&gt;<br />
&lt;tr&gt;<br />
&lt;th colspan=&quot;2&quot;&gt;&lt;/th&gt;<br />
&lt;th&gt;How?&lt;/th&gt;<br />
&lt;th&gt; 目录项内容 &lt;/th&gt;<br />
&lt;th&gt; 优点 &lt;/th&gt;<br />
&lt;th&gt; 缺点 &lt;/th&gt;<br />
&lt;/tr&gt;<br />
&lt;/thead&gt;<br />
&lt;tbody&gt;<br />
&lt;tr&gt;<br />
&lt;td colspan=&quot;2&quot;&gt; 顺序分配 &lt;/td&gt;<br />
&lt;td&gt; 为文件分配的必须是连续的磁盘块 &lt;/td&gt;<br />
&lt;td&gt; 起始块号、文件长度 &lt;/td&gt;<br />
&lt;td&gt; 顺序存取速度快，支持随机访问 &lt;/td&gt;<br />
&lt;td&gt; 会产生碎片，不利于文件拓展 &lt;/td&gt;<br />
&lt;/tr&gt;<br />
&lt;tr&gt;<br />
&lt;td rowspan=&quot;2&quot;&gt; 链接分配 &lt;/td&gt;<br />
&lt;td&gt; 隐式链接 &lt;/td&gt;<br />
&lt;td&gt; 出文件的最后一个盘块之外，每个盘块都存有下一个盘块的指针 &lt;/td&gt;<br />
&lt;td&gt; 起始块号、结束块号 &lt;/td&gt;<br />
&lt;td&gt; 可解决碎片问题，外村利用率高，文件拓展方便实现 &lt;/td&gt;<br />
&lt;td&gt; 只能顺序访问，不能随机访问 &lt;/td&gt;<br />
&lt;/tr&gt;<br />
&lt;tr&gt;<br />
&lt;td&gt; 显式链接 &lt;/td&gt;<br />
&lt;td&gt; 建立一张文件分配表 ( FAT ), 显示记录盘块的先后关系 &lt;/br&gt;(开机后 FAT 常驻内存)&lt;/td&gt;<br />
&lt;td&gt; 起始块号 &lt;/td&gt;<br />
&lt;td&gt; 除了拥有隐式链接的优点外，还可以通过查询内存中的 FAT 实现随机访问 &lt;/td&gt;<br />
&lt;td&gt;FAT 需要占用一定的存储空间 &lt;/td&gt;<br />
&lt;/tr&gt;<br />
&lt;td colspan=&quot;2&quot;&gt; 索引分配 &lt;/td&gt;<br />
&lt;td&gt; 为文件数据块建立索引表，若文件太大，可采用链接方案、多层索引、混合索引 &lt;/td&gt;<br />
&lt;td&gt; 链接方案记录的是第一个索引块的块号，多层 / 混合索引记录的是顶级索引块的块号 &lt;/td&gt;<br />
&lt;td&gt; 支持随机访问，易于实现文件的拓展 &lt;/td&gt;<br />
&lt;td&gt; 索引表需占用一定的存储空间。访问数据块前需要先读入索引块，查找索引块时可能需要多次都磁盘操作 &lt;/td&gt;<br />
&lt;/tr&gt;<br />
&lt;/tbody&gt;<br />
&lt;/table&gt;</p>
<h1 id="文件存储空间管理对空闲磁盘块管理"><a class="anchor" href="#文件存储空间管理对空闲磁盘块管理">#</a> 文件存储空间管理（对空闲磁盘块管理）</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216213358896.png" alt="image-20230216213358896" /></p>
<hr />
<h2 id="存储空间的划分与初始化"><a class="anchor" href="#存储空间的划分与初始化">#</a> 存储空间的划分与初始化</h2>
<p>安装 Windows 操作系统的时候，一个必经步骤是――为磁盘分区（C: 盘、D: 盘、E: 盘等）</p>
<ul>
<li>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘)</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216213723772.png" alt="image-20230216213723772" /></p>
<h2 id="空闲表法"><a class="anchor" href="#空闲表法">#</a> 空闲表法</h2>
<p><strong>适用于 &quot;连续分配方式&quot;</strong></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216214940121.png" alt="image-20230216214940121" /></p>
<p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>分配连续的存储空间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}分配连续的存储空间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">分配连续的存储空间</span></span></span></span>。同样<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可采用首次适应、最佳适应、最坏适应等算法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可采用首次适应、最佳适应、最坏适应等算法</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可采用首次适应、最佳适应、最坏适应等算法</span></span></span></span>来决定要为文件分配哪个区间。</p>
<p>Eg：新创建的文件请求 3 个块，采用<strong>首次适应算法</strong></p>
<ul>
<li>每次都从第一个空闲盘块号开始查找，找到第一个能满足大小的空闲盘块。</li>
</ul>
<hr />
<p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况―—</p>
<p>① 回收区的前后都没有相邻空闲区；</p>
<p>② 回收区的前后都是空闲区；</p>
<ul>
<li>合并</li>
</ul>
<p>③ 回收区前面是空闲区；</p>
<ul>
<li>合并</li>
</ul>
<p>④ 回收区后面是空闲区。</p>
<ul>
<li>合并</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>总之，回收时需要注意表项的合并问题</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}总之，回收时需要注意表项的合并问题</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">总之，回收时需要注意表项的合并问题</span></span></span></span>。</p>
<hr />
<p>例如：② 回收区的前后都是空闲区；</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216215708925.png" alt="image-20230216215708925" /></p>
<hr />
<h2 id="空闲链表法"><a class="anchor" href="#空闲链表法">#</a> 空闲链表法</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216215910501.png" alt="image-20230216215910501" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216220352619.png" alt="image-20230216220352619" /></p>
<h3 id="空闲盘块链"><a class="anchor" href="#空闲盘块链">#</a> 空闲盘块链</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216220135738.png" alt="image-20230216220135738" /></p>
<p>操作系统保存着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链头、链尾指针</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链头、链尾指针</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链头、链尾指针</span></span></span></span>。</p>
<p>如何分配：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。</p>
<p>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p>
<hr />
<p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p>
<ul>
<li>依次从链头摘下</li>
</ul>
<h3 id="空闲盘区链"><a class="anchor" href="#空闲盘区链">#</a> 空闲盘区链</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216220409558.png" alt="image-20230216220409558" /></p>
<p>操作系统保存着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>链头、链尾指针</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}链头、链尾指针</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">链头、链尾指针</span></span></span></span>。</p>
<p>如何分配：若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。</p>
<ul>
<li>若没有合适的连续空闲块，也可以将<strong>不同盘区的盘块同时分配给一个文件</strong>，注意分配后可能要修改相应的链指针、盘区大小等数据。</li>
</ul>
<p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。</p>
<ul>
<li>若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li>
</ul>
<hr />
<p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</p>
<ul>
<li>可以一次摘下多个盘块</li>
</ul>
<h3 id="位示图法"><a class="anchor" href="#位示图法">#</a> 位示图法</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216221733384.png" alt="image-20230216221733384" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>位示图</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}位示图</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">位示图</span></span></span></span>：每个二进制位对应一个盘块。在本例中，“0” 代表盘块空闲，“1” 代表盘块已分配。</p>
<p>位示图一般用连续的 “字” 来表示，如本例中一个字的字长是 16 位，字中的每一位对应一个盘块。</p>
<p>因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可以用（字号，位号）对应一个盘块号</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可以用（字号，位号）对应一个盘块号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可以用（字号，位号）对应一个盘块号</span></span></span></span>。当然有的题目中也描述为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>（行</mtext><mo>&lt;</mo><mtext>号，列号）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}（行&lt;号，列号）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback" style="color:red;">（行</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">号，列号）</span></span></span></span></p>
<p>注意：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>盘块号、字号、位号</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}盘块号、字号、位号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">盘块号、字号、位号</span></span></span></span>到底是从 0 开始还是从 1 开始。</p>
<ul>
<li>要能自己推出盘块号与（字号，位号）相互转换的公式</li>
</ul>
<p>如本例中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>盘块号、字号、位号从</mtext><mn>0</mn><mtext>开始</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}盘块号、字号、位号从 0 开始</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">盘块号、字号、位号从</span><span class="mord" style="color:red;">0</span><span class="mord cjk_fallback" style="color:red;">开始</span></span></span></span>，若 n 表示字长，则...</p>
<p>（字号，位号）= （i，j）的二进制位对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>盘块号</mtext><mi>b</mi><mo>=</mo><mi>n</mi><mi>i</mi><mo>+</mo><mi>j</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}盘块号 b = ni + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">盘块号</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="color:red;">ni</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;color:red;">j</span></span></span></span></p>
<ul>
<li>
<p>（0，1）-&gt; 16 * 0 + 1 = 1</p>
</li>
<li>
<p>（1，10）-&gt; 16 * 1 + 10 = 26</p>
</li>
</ul>
<p>b 号盘块对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>字号</mtext><mi>i</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>n</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}字号 i = b / n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">字号</span><span class="mord mathnormal" style="color:red;">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>位号</mtext><mi>j</mi><mo>=</mo><mi>b</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}位号 j = b % n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">位号</span><span class="mord mathnormal" style="margin-right:0.05724em;color:red;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="color:red;">b</span></span></span></span></p>
<ul>
<li>b = 13 -&gt; i = 13 / 16 = 0，j = 13 % 16 = 13</li>
<li>b = 31 -&gt; i = 31 / 16 = 1，j = 31 % 16 = 15</li>
</ul>
<hr />
<p><strong>如何分配</strong>：若文件需要 K 个块</p>
<ul>
<li>① 顺序扫描位示图，找到 K 个相邻或不相邻的 “0”;</li>
<li>② 根据字号、位号算出对应的盘块号，将相应盘块分配给文件；</li>
<li>③ 将相应位设置为 “1”。</li>
</ul>
<p><strong>如何回收</strong>：</p>
<ul>
<li>① 根据回收的盘块号计算出对应的字号、位号；</li>
<li>② 将相应二进制位设为 “0”</li>
</ul>
<hr />
<p>连续分配、离散分配都适用</p>
<ul>
<li>若采用连续分配，在位示图中找到连续的 k 个 &quot;0&quot;</li>
<li>若采用离散分配，在位示图中不需要找到连续的 k 个 &quot;0&quot;</li>
</ul>
<h2 id="成组链接法"><a class="anchor" href="#成组链接法">#</a> 成组链接法</h2>
<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。 <code>UNIX</code>  系统中采用了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>成组链接法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}成组链接法</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">成组链接法</span></span></span></span>对磁盘空闲块进行管理。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件卷的目录区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件卷的目录区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件卷的目录区</span></span></span></span>中专门用一个<strong>磁盘块</strong>作为 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>超级块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}超级块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">超级块</span></span></span></span>”，当系统启动时需要将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>超级块读入内存</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}超级块读入内存</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">超级块读入内存</span></span></span></span>。并且要保证内存与外存中的 “超级块” 数据一致。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216222454670.png" alt="image-20230216222454670" /></p>
<hr />
<p><strong>每一个分组最后一个盘块号记录者下一个分组的盘块地址</strong></p>
<p>最后一个分组比其他分组要少一块，因为到此已经没有下一组盘块了</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216223039616.png" alt="image-20230216223039616" /></p>
<p><strong>如何分配？</strong></p>
<p>Eg：需要 1 个空闲块</p>
<p>① 检查第一个分组的块数是否足够。1 &lt; 100，因此是足够的。</p>
<p>② 分配第一个分组中的 1 个空闲块，并修改相应数据</p>
<p>Eg：需要 100 个空闲块</p>
<p>① 检查第一个分组的块数是否足够。100 = 100，因此是足够的。</p>
<p>② 分配第一个分组中的 100 个空闲块。但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>由于</mtext><mn>300</mn><mtext>号块内存放了再下一组的信息，因此</mtext><mn>300</mn><mtext>号块的数据需要复制到超级块中</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}由于 300 号块内存放了再下一组的信息，因此 300 号块的数据需要复制到超级块中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">由于</span><span class="mord" style="color:red;">300</span><span class="mord cjk_fallback" style="color:red;">号块内存放了再下一组的信息，因此</span><span class="mord" style="color:red;">300</span><span class="mord cjk_fallback" style="color:red;">号块的数据需要复制到超级块中</span></span></span></span>。</p>
<ul>
<li>即：需要将这个分组指向下一分组的链接信息复制到超级块中</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216223624710.png" alt="image-20230216223624710" /></p>
<hr />
<p><strong>如何回收？</strong></p>
<p>Eg：假设每个分组最多为 100 个空闲块，此时第一个分组已有 99 个块，还要再回收一个块</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216224050902.png" alt="image-20230216224050902" /></p>
<p>Eg：假设每个分组最多为 100 个空闲块，此时第一个分组已有 100 个块，还要再回收一个块</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216224355411.png" alt="image-20230216224355411" /></p>
<h2 id="整体框架-4"><a class="anchor" href="#整体框架-4">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230216225001772.png" alt="image-20230216225001772" /></p>
<h1 id="文件的基本操作"><a class="anchor" href="#文件的基本操作">#</a> 文件的基本操作</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217000905970.png" alt="image-20230217000905970" /></p>
<h2 id="创建文件"><a class="anchor" href="#创建文件">#</a> 创建文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217000937551.png" alt="image-20230217000937551" /></p>
<p>进行 Create 系统调用时，需要提供的几个主要参数:</p>
<ol>
<li>所需的外存空间大小（如：一个盘块，即 1 KB）</li>
<li>文件存放路径（&quot;D:/Demo&quot;）</li>
<li>文件名（这个地方默认为 &quot;新建文本文档.txt&quot;）</li>
</ol>
<p>操作系统在处理 Create 系统调用时，主要做了两件事：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在外存中找到文件所需的空间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在外存中找到文件所需的空间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在外存中找到文件所需的空间</span></span></span></span>（空闲链表、位示图、成组链接法等管理策略，找到空闲空间）</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>创建该文件对应的目录项</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}创建该文件对应的目录项</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">创建该文件对应的目录项</span></span></span></span>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
<h2 id="删除文件"><a class="anchor" href="#删除文件">#</a> 删除文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217001614730.png" alt="image-20230217001614730" /></p>
<p>进行 Delete 系统调用时，需要提供的几个主要参数:</p>
<ol>
<li>文件存放路径（“D:/Demo”)</li>
<li>文件名（“test.txt”)</li>
</ol>
<p>操作系统在处理 Delete 系统调用时，主要做了几件事:</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>找到文件名对应的目录项</mtext><mi>F</mi><mi>C</mi><mi>B</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}找到文件名对应的目录项 FCB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">找到文件名对应的目录项</span><span class="mord mathnormal" style="margin-right:0.05017em;color:red;">FCB</span></span></span></span>。</li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>回收文件占用的磁盘块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}回收文件占用的磁盘块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">回收文件占用的磁盘块</span></span></span></span>。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</li>
</ol>
<hr />
<h2 id="打开文件"><a class="anchor" href="#打开文件">#</a> 打开文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217002245088.png" alt="image-20230217002245088" /></p>
<p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用 “打开文件”，需要提供的几个主要参数:</p>
<ol>
<li>文件存放路径（“D:/Demo”）</li>
<li>文件名（“test.txt”）</li>
<li>要对文件的操作类型（如: r 只读；rw 读写等)</li>
</ol>
<p>操作系统在处理 open 系统调用时，主要做了几件事:</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录项中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>找到文件名对应的目录项</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}找到文件名对应的目录项</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">找到文件名对应的目录项</span></span></span></span>，并检查该用户是否有指定的操作权限。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>将目录项复制到内存中的“打开文件表”中</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}将目录项复制到内存中的 “打开文件表” 中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">将目录项复制到内存中的</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">打开文件表</span><span class="mord" style="color:red;">”</span><span class="mord cjk_fallback" style="color:red;">中</span></span></span></span>。并将对应表目的编号返回给用户。之后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>用户使用打开文件表的编号来指明要操作的文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}用户使用打开文件表的编号来指明要操作的文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">用户使用打开文件表的编号来指明要操作的文件</span></span></span></span>。</li>
</ol>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217002827178.png" alt="image-20230217002827178" /></p>
<p>打开计数器：记录此时有多少个进程打开了此文件</p>
<p>读写指针：记录了该进程对文件的读 / 写操作进行到的位置</p>
<p>可以方便实现某些文件管理的功能。</p>
<p>例如：在 Windows 系统中，我们尝试删除某个 txt 文件，如果此时该文件已被某个 “记事本” 进 程打开，则系统会提示我们 “暂时无法删除该文件” 。</p>
<ul>
<li>其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。</li>
</ul>
<hr />
<h2 id="关闭文件"><a class="anchor" href="#关闭文件">#</a> 关闭文件</h2>
<p>进程使用完文件后，要 “关闭文件”</p>
<p>操作系统在处理 Close 系统调用时，主要做了几件事:</p>
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的计数器 count 减 1，若 count = 0，择善书对应表项</li>
</ol>
<h2 id="读文件"><a class="anchor" href="#读文件">#</a> 读文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217003728571.png" alt="image-20230217003728571" /></p>
<p>进程使用 read 系统调用完成写操作。</p>
<ul>
<li>
<p>需要指明是哪个文件（在支持 “打开文件” 操作的系统中，只需要提供文件在打开文件表中的<strong>索引号</strong>即可)，</p>
</li>
<li>
<p>还需要指明要读入多少数据（如：读入 1 KB ）</p>
</li>
<li>
<p>指明读入的数据要放在内存中的什么位置。</p>
</li>
</ul>
<p>操作系统在处理 read 系统调用时，会<strong>从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</strong></p>
<h2 id="写文件"><a class="anchor" href="#写文件">#</a> 写文件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217004404747.png" alt="image-20230217004404747" /></p>
<p>进程使用 write 系统调用完成写操作</p>
<ul>
<li>需要指明是哪个文件（在支持 “打开文件” 操作的系统中，只需要提供文件在打开文件表中的索引号即可)，</li>
<li>还需要指明要写出多少数据（如：写出 1KB）</li>
<li>写回外存的数据放在内存中的什么位置</li>
</ul>
<p>操作系统在处理 write 系统调用时，<strong>会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</strong></p>
<hr />
<h2 id="整体框架-5"><a class="anchor" href="#整体框架-5">#</a> 整体框架</h2>
<p><strong>打开文件时并不会把文件数据直接读入内存</strong>。</p>
<p><strong>只有读文件时，才会将文件数据从外村读入内存</strong></p>
<p>“索引号” 也称 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件描述符</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件描述符</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件描述符</span></span></span></span>”</p>
<p>“读 / 写文件” 用 “文件描述符” 即可指明文件，不再需要用到 “文件名”</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230217005559213.png" alt="image-20230217005559213" /></p>
<h1 id="文件共享"><a class="anchor" href="#文件共享">#</a> 文件共享</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219175622127.png" alt="image-20230219175622127" /></p>
<p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注意</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意</span></span></span></span>：多个用户共享同一个文件，意味着系统中只有 “一份” 文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p>
<p>如果是多个用户都 “复制” 了同一个文件，那么系统中会有 “好几份” 文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p>
<hr />
<h2 id="基于索引节点的共享方式硬链接"><a class="anchor" href="#基于索引节点的共享方式硬链接">#</a> 基于索引节点的共享方式（硬链接）</h2>
<p>知识回顾：索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219175947703.png" alt="image-20230219175947703" /></p>
<p>索引结点中设置一个链接计数变量  <code>count</code> ，用于表示链接到本索引结点上的用户目录项数。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219180019128.png" alt="image-20230219180019128" /></p>
<p>若  <code>count = 2</code> ，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</p>
<hr />
<p>若某个用户决定 “删除” 该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的  <code>count</code>  值减 <code>1</code> 。</p>
<p>若  <code>count &gt; 0</code> ，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p>
<p>当  <code>count = 0</code>  时系统负责删除文件。</p>
<hr />
<h2 id="基于符号链的共享方式软链接"><a class="anchor" href="#基于符号链的共享方式软链接">#</a> 基于符号链的共享方式（软链接）</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219180309098.png" alt="image-20230219180309098" /></p>
<p>当  <code>User3</code>  访问 “ccc” 时，操作系统判断文件 “ccc” 属于  <code>Link</code>  类型文件，于是会根据其中记录的路径层层查找目录，最终找到  <code>User1</code>  的目录表中的 “aaa” 表项，于是就找到了文件 1 的索引结点。</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219180535680.png" alt="image-20230219180535680" /></p>
<hr />
<p><strong>删除文件后，在访问快捷方式</strong></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219180656527.png" alt="image-20230219180656527" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219180803294.png" alt="image-20230219180803294" /></p>
<h2 id="整体框架-6"><a class="anchor" href="#整体框架-6">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219181037779.png" alt="image-20230219181037779" /></p>
<h1 id="文件保护"><a class="anchor" href="#文件保护">#</a> 文件保护</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219181816899.png" alt="image-20230219181816899" /></p>
<h2 id="口令保护"><a class="anchor" href="#口令保护">#</a> 口令保护</h2>
<p>为文件设置一个 “口令” (如: abc112233），用户请求访问该文件时必须提供 “口令” 。</p>
<p>口令一般存放在文件对应的  <code>FCB</code>  或索引结点中。用户访问文件前需要先输入 “口令”，操作系统会将用户提供的口令与  <code>FCB</code>  中存储的口令进行对比，如果正确，则允许该用户访问文件</p>
<hr />
<p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p>
<p>缺点：正确的 “口令” 存放在系统内部，不够安全。</p>
<ul>
<li>若系统被入侵</li>
</ul>
<h2 id="加密保护"><a class="anchor" href="#加密保护">#</a> 加密保护</h2>
<p>使用某个 “密码” 对文件进行加密，在访问文件时需要提供正确的 “密码” 才能对文件进行正确的解密。</p>
<p>Eg：一个最简单的加密算法 —―异或加密假设用于加密 / 解密的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>“密码”为“</mtext><mn>01001</mn><mtext>”</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}“密码” 为 “01001”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">密码</span><span class="mord" style="color:red;">”</span><span class="mord cjk_fallback" style="color:red;">为</span><span class="mord" style="color:red;">“01001”</span></span></span></span></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219182406963.png" alt="image-20230219182406963" /></p>
<p>优点：保密性强，不需要在系统中存储 “密码”<br />
 缺点：编码 / 译码，或者说加密 / 解密要花费一定时间。</p>
<h2 id="控制访问精简访问控制表"><a class="anchor" href="#控制访问精简访问控制表">#</a> 控制访问（(精简) 访问控制表）</h2>
<p>在每个文件的  <code>FCB</code> （或索引结点）中增加一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>访问控制列表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}访问控制列表</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">访问控制列表</span></span></span></span>（Access-Control List，ACL)，该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219182657190.png" alt="image-20230219182657190" /></p>
<p>有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题</p>
<hr />
<p>精简的访问列表：以 “组” 为单位，标记各 “组” 用户可以对文件执行哪些操作。如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p>
<p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</p>
<ul>
<li>系统需要管理分组的信息</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219182820026.png" alt="image-20230219182820026" /></p>
<p>若想要让某个用户能够读取文件，只需要把该用户放入 &quot;文件主的伙伴&quot; 这个分组即可</p>
<hr />
<h2 id="整体框架-7"><a class="anchor" href="#整体框架-7">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219183445929.png" alt="image-20230219183445929" /></p>
<p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p>
<h1 id="文件系统的层次结构"><a class="anchor" href="#文件系统的层次结构">#</a> 文件系统的层次结构</h1>
<p>对于文件的逻辑结构，其中的索引文件，会问文件的记录建立索引表，为了查询这些记录对应的逻辑地址而需要查询索引表。在查询索引表之前需要将其调入到内存的文件信息缓冲区。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219220206171.png" alt="image-20230219220206171" /></p>
<hr />
<p>用一个例子来辅助记忆文件系统的层次结构:</p>
<p>假设某用户请求删除文件 “D:/ 工作目录 / 学生信息.xlsx” 的最后 100 条记录。</p>
<ol>
<li>
<p>用户需要通过操作系统提供的接口发出上述请求――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>用户接口</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}用户接口</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">用户接口</span></span></span></span></p>
</li>
<li>
<p>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项 —―<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件目录系统</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件目录系统</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件目录系统</span></span></span></span> <a href="#4.3%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">4.3、文件目录</a></p>
</li>
<li>
<p>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限 —―<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>存取控制模块（存取控制验证层</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}存取控制模块（存取控制验证层)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">存取控制模块（存取控制验证层</span><span class="mclose" style="color:red;">)</span></span></span></span> <a href="#4.8%E3%80%81%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4">4.8、文件保护</a></p>
<ul>
<li>因为权限的数据在  <code>FCB</code>  或者  <code>FCB</code>  瘦身后的索引节点里面</li>
</ul>
</li>
<li>
<p>验证了用户的访问权限之后，需要把用户提供的 “记录号” 转变为对应的逻辑地址――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑文件系统与文件信息缓冲区 </mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑文件系统与文件信息缓冲区 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑文件系统与文件信息缓冲区</span><span class="mord" style="color:red;"> </span></span></span></span><a href="#4.2%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">4.2、文件的逻辑结构</a></p>
</li>
<li>
<p>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理文件系统 </mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理文件系统 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理文件系统</span><span class="mord" style="color:red;"> </span></span></span></span><a href="#4.4%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%88%E5%AF%B9%E9%9D%9E%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%89">4.4、文件的物理结构（文件分配方式）（对非空闲磁盘块的管理）</a></p>
</li>
<li>
<p>要删除这条记录，必定要对磁盘设备发出请求――$\color {red} 设备管理程序模块 $[ 5、设备管理](# 5、设备管理)</p>
</li>
<li>
<p>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>辅助分配模块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}辅助分配模块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">辅助分配模块</span></span></span></span>  <a href="#4.5%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%EF%BC%88%E5%AF%B9%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%AE%A1%E7%90%86%EF%BC%89">4.5、文件存储空间管理（对空闲磁盘块管理）</a></p>
</li>
</ol>
<h1 id="磁盘的结构"><a class="anchor" href="#磁盘的结构">#</a> 磁盘的结构</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219221809202.png" alt="image-20230219221809202" /></p>
<h2 id="磁盘-磁道-扇区"><a class="anchor" href="#磁盘-磁道-扇区">#</a> 磁盘、磁道、扇区</h2>
<p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219221854426.png" alt="image-20230219221854426" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219222322532.png" alt="image-20230219222322532" /></p>
<h2 id="如何在磁盘中读写数据"><a class="anchor" href="#如何在磁盘中读写数据">#</a> 如何在磁盘中读 / 写数据</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219221854426.png" alt="image-20230219221854426" /></p>
<p>需要把 &quot;磁头&quot; 移动到想要读 / 写的扇区所在的磁道</p>
<p>磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读 / 写操作。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/citou.gif" alt="citou.gif" /></p>
<hr />
<h2 id="盘面-柱面"><a class="anchor" href="#盘面-柱面">#</a> 盘面、柱面</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219222903755.png" alt="image-20230219222903755" /></p>
<p>可用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>（柱面号，盘面号，扇区号）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}（柱面号，盘面号，扇区号）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">（柱面号，盘面号，扇区号）</span></span></span></span>来定位任意一个 “磁盘块”。在 “文件的物理结构” 小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p>
<p>可根据该地址读取一个 “块”</p>
<p>① 根据 “柱面号” 移动磁臂，让磁头指向指定柱面；</p>
<p>② 激活指定盘面对应的磁头；</p>
<p>③ 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读 / 写。</p>
<h2 id="磁盘的分类"><a class="anchor" href="#磁盘的分类">#</a> 磁盘的分类</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219223246122.png" alt="image-20230219223246122" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219223313401.png" alt="image-20230219223313401" /></p>
<h2 id="整体框架-8"><a class="anchor" href="#整体框架-8">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230219224420768.png" alt="image-20230219224420768" /></p>
<h1 id="磁盘调度算法"><a class="anchor" href="#磁盘调度算法">#</a> 磁盘调度算法</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220190513034.png" alt="image-20230220190513034" /></p>
<h2 id="一次盘读写操作需要的时间"><a class="anchor" href="#一次盘读写操作需要的时间">#</a> 一次盘读 / 写操作需要的时间</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>寻找时间（寻道时间）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}寻找时间（寻道时间）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">寻找时间（寻道时间）</span></span></span></span> <code>Ts</code> ：在读 / 写数据前，将磁头移动到指定磁道所花的时间。</p>
<p>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>启动磁头</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}启动磁头</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">启动磁头</span></span></span></span>臂是需要时间的。假设耗时为  <code>s</code>  ;<br />
② <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>移动磁头</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}移动磁头</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">移动磁头</span></span></span></span>也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为  <code>m</code> ，总共需要跨越  <code>n</code>  条磁道。则:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>寻找时间</mtext><mi>T</mi><mi>s</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>m</mi><mo>∗</mo><mi>n</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}寻找时间 Ts = s + m * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">寻找时间</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord mathnormal" style="color:red;">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="color:red;">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="color:red;">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="color:red;">n</span></span></span></span></p>
<ul>
<li>现在的硬盘移动一个磁道大约需要 0.2 ms，磁臂启动时间约为 2 ms</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/citoumove.gif" alt="citoumove.gif" /></p>
<hr />
<p>$\color {red} 延迟时间 T&lt;sub&gt;r&lt;/sub&gt; $：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p>
<p>设磁盘转速为  <code>r</code>  （单位：转 / 秒，或转 / 分） ，则平均所需的延迟时间 T&lt;sub&gt;r&lt;/sub&gt; = (1/2) * (1/r) = 1/2r</p>
<ul>
<li>1/r 就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以 1/2</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/cipan.gif" alt="cipan.gif" /></p>
<p>硬盘的典型转速为 5400 转 / 分，或 7200 转 / 分</p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>传输时间</mtext><mi>T</mi><mo>&lt;</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo>&gt;</mo><mi>t</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>s</mi><mi>u</mi><mi>b</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}传输时间 T&lt;sub&gt;t&lt;/sub&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback" style="color:red;">传输时间</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span></span></span></span> ：从磁盘读出或向磁盘写入数据所经历的时间</p>
<p>假设磁盘转速为  <code>r</code> ，此次读 / 写的字节数为  <code>b</code> ，每个磁道上的字节数为  <code>N</code> 。</p>
<p>则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>传输时间</mtext><mi>T</mi><mo>&lt;</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo>&gt;</mo><mi>t</mi><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>s</mi><mi>u</mi><mi>b</mi><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>r</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>r</mi><mi>N</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}传输时间 T&lt;sub&gt;t&lt;/sub&gt; = (1/r) * (b/N) = b/(rN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback" style="color:red;">传输时间</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="color:red;">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord" style="color:red;">1/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mclose" style="color:red;">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="color:red;">b</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mclose" style="color:red;">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="color:red;">b</span><span class="mord" style="color:red;">/</span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">r</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
<ul>
<li>每个磁道要可存  <code>N</code>  字节的数据，因此  <code>b</code>  字节的数据需要  <code>b/N</code>  个磁道才能存储。而读 / 写一个磁道所需的时间<br />
刚好又是转一圈所需要的时间  <code>1/r</code></li>
</ul>
<hr />
<p>总的平均存取时间 T&lt;sub&gt;a&lt;/sub&gt; = T&lt;sub&gt;s&lt;/sub&gt;+ 1/2r + b/(rN)</p>
<hr />
<p>延迟时间和传输时间都与磁盘转速相关，宜为线性相关。而转速是硬件的固有属性，<strong>因此操作系统也无法优化延迟</strong><br />
<strong>时间和传输时间</strong></p>
<p><strong>但是操作系统的磁盘调度算法会直接影响寻道时间</strong></p>
<hr />
<h2 id="先来先服务算法fcfs"><a class="anchor" href="#先来先服务算法fcfs">#</a> 先来先服务算法（FCFS）</h2>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<p>假设磁头的初始位置是 100 号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p>按照  <code>FCFS</code>  的规则，按照请求到达的顺序，磁头需要依次移动到 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220192523469.png" alt="image-20230220192523469" /></p>
<p>磁头总共移动了 45+3+19+21+72+70+10+112+146 = 498 个磁道</p>
<p>响应一个请求平均需要移动 498/9 = 55.3 个磁道（平均寻找长度)</p>
<hr />
<p><strong>优点</strong>：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</p>
<p><strong>缺点</strong>：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则  <code>FCFS</code>  在性能上很差，寻道时间长。</p>
<hr />
<h2 id="最短寻找时间优先sstf"><a class="anchor" href="#最短寻找时间优先sstf">#</a> 最短寻找时间优先（SSTF）</h2>
<p><code>SSTF</code>  算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p>
<p>假设磁头的初始位置是 100 号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220193053980.png" alt="image-20230220193053980" /></p>
<p>磁头总共移动了 (100-18) + (184-18) = 248 个磁道</p>
<p>响应一个请求平均需要移动 248/9 = 27.5 个磁道（平均寻找长度)</p>
<p><strong>优点</strong>：性能较好，平均寻道时间短</p>
<p><strong>缺点</strong>：$\color {red} 可能产生 “饥饿” $ 现象</p>
<ul>
<li>
<p>Eg：本例中，如果在处理 18 号磁道的访问请求时又来了一个 38 号磁道的访问请求，处理 38 号磁道的访问请求时又来了一个 18 号磁道的访问请求。如果有源源不断的 18 号、38 号磁道的访问请求到来的话，150、160、184 号磁道的访问请求就永远得不到满足，从而产生 “饥饿” 现象。</p>
</li>
<li>
<p>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动</p>
</li>
</ul>
<hr />
<h2 id="扫描电梯算法scan"><a class="anchor" href="#扫描电梯算法scan">#</a> 扫描 (电梯) 算法（SCAN）</h2>
<p><code>SSTF</code>  算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。</p>
<p>为了防止这个问题，可以规定，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</span></span></span></span>。</p>
<ul>
<li>这就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>扫描算法（</mtext><mi>S</mi><mi>C</mi><mi>A</mi><mi>N</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}扫描算法（SCAN）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">扫描算法（</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">SC</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>的思想。由于磁头移动的方式很像电梯，因此也叫<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>电梯算法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}电梯算法</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">电梯算法</span></span></span></span>。</li>
</ul>
<hr />
<p>假设某磁盘的磁道为 0 ~ 200 号，磁头的初始位置是 100 号磁道，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>此时磁头正在往磁道号增大的方向移动</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}此时磁头正在往磁道号增大的方向移动</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">此时磁头正在往磁道号增大的方向移动</span></span></span></span>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220193716276.png" alt="image-20230220193716276" /></p>
<p>磁头总共移动了 (200-100) + (200-18) = 282 个磁道</p>
<p>响应一个请求平均需要移动 282/9 = 31.3 个磁道（平均寻找长度)</p>
<p><strong>优点</strong>：性能较好，平均寻道时间较短，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不会产生饥饿现象</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不会产生饥饿现象</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不会产生饥饿现象</span></span></span></span></p>
<p><strong>缺点</strong>：</p>
<p>① 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了 184 号磁道的访问请求之后就不需要再往右移动磁头了。</p>
<p>②  <code>SCAN</code>  算法对于<strong>各个位置磁道的响应频率不平均</strong></p>
<ul>
<li>如：假设此时磁头正在往右移动，且刚处理过 90 号磁道，那么下次处理 90 号磁道的请求就需要等磁头移动很长一段距离；而响应了 184 号磁道的请求之后，很快又可以再次响应 184 号磁道的请求了</li>
</ul>
<hr />
<h2 id="lock-调度算法"><a class="anchor" href="#lock-调度算法">#</a> LOCK 调度算法</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>扫描算法（</mtext><mi>S</mi><mi>C</mi><mi>A</mi><mi>N</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}扫描算法（SCAN）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">扫描算法（</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">SC</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了 184 号磁道的访问请求之后就不需要再往右移动磁头了。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>L</mi><mi>O</mi><mi>O</mi><mi>K</mi><mtext>调度算法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}LOOK 调度算法</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">OO</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">K</span><span class="mord cjk_fallback" style="color:red;">调度算法</span></span></span></span>就是为了解决这个问题，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</span></span></span></span></p>
<ul>
<li>边移动边观察，因此叫  <code>LOOK</code></li>
</ul>
<hr />
<p>假设某磁盘的磁道为 0 ~ 200 号，磁头的初始位置是 100 号磁道，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>此时磁头正在往磁道号增大的方向移动</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}此时磁头正在往磁道号增大的方向移动</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">此时磁头正在往磁道号增大的方向移动</span></span></span></span>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220194317231.png" alt="image-20230220194317231" /></p>
<p>磁头总共移动了 (184 - 100) + (184 -18) = 250 个磁道</p>
<p>响应一个请求平均需要移动 250/9= 27.5 个磁道（平均寻找长度)</p>
<p>优点：比起  <code>SCAN</code>  算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>
<hr />
<h2 id="循环扫描算法c-scan"><a class="anchor" href="#循环扫描算法c-scan">#</a> 循环扫描算法（C-SCAN）</h2>
<p><code>SCAN</code>  算法对于各个位置磁道的响应频率不平均，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>C</mi><mo>−</mo><mi>S</mi><mi>C</mi><mi>A</mi><mi>N</mi><mtext>算法</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}C-SCAN 算法</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">SC</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">N</span><span class="mord cjk_fallback" style="color:red;">算法</span></span></span></span>就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>返回时直接快速移动至起始端而不处理任何请求</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}返回时直接快速移动至起始端而不处理任何请求</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">返回时直接快速移动至起始端而不处理任何请求</span></span></span></span>。</p>
<hr />
<p>假设某磁盘的磁道为 0 ~ 200 号，磁头的初始位置是 100 号磁道，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>此时磁头正在往磁道号增大的方向移动</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}此时磁头正在往磁道号增大的方向移动</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">此时磁头正在往磁道号增大的方向移动</span></span></span></span>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220194645833.png" alt="image-20230220194645833" /></p>
<p>磁头总共移动了 (200-100) + (200 - 0)+ (90 - 0) = 390 个磁道</p>
<p>响应一个请求平均需要移动 390/9 = 43.3 个磁道（平均寻找长度)</p>
<p><strong>优点</strong>：比起  <code>SCAN</code>  来，对于<strong>各个位置磁道的响应频率很平均</strong>。</p>
<p><strong>缺点</strong>：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了 184 号磁道的访问请求之后就不需要再往右移动磁头了；</p>
<ul>
<li>
<p>并且，磁头返回时其实只需要返回到 18 号磁道即可，不需要返回到最边缘的磁道。</p>
</li>
<li>
<p>另外，比起  <code>SCAN</code>  算法来，平均寻道时间更长。</p>
</li>
</ul>
<hr />
<h2 id="c-look-算法"><a class="anchor" href="#c-look-算法">#</a> C-LOOK 算法</h2>
<p><code>C-SCAN</code>  算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。</p>
<p><code>C-LOOK</code>  算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<p>假设某磁盘的磁道为 0 ~ 200 号，磁头的初始位置是 100 号磁道，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>此时磁头正在往磁道号增大的方向移动</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}此时磁头正在往磁道号增大的方向移动</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">此时磁头正在往磁道号增大的方向移动</span></span></span></span>，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220195005460.png" alt="image-20230220195005460" /></p>
<p>磁头总共移动了 (184 - 100) + (184 -18) + (90 - 18) = 322 个磁道</p>
<p>响应一个请求平均需要移动 322/9 = 35.8 个磁道（平均寻找长度)</p>
<p><strong>优点</strong>：比起  <code>C-SCAN</code>  算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>
<hr />
<h2 id="整体框架-9"><a class="anchor" href="#整体框架-9">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220195424923.png" alt="image-20230220195424923" /></p>
<p>寻找时间（寻道时间）：启动磁臂移动磁头所花的时间</p>
<ul>
<li>磁盘调度算法影响的指标</li>
</ul>
<hr />
<h1 id="减少磁盘延迟时间的办法"><a class="anchor" href="#减少磁盘延迟时间的办法">#</a> 减少磁盘延迟时间的办法</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220203218990.png" alt="image-20230220203218990" /></p>
<p>假设要连续读取橙色区域的 2、3、4 扇区:</p>
<p>磁头读取一块的内容（也就是一个扇区的内容）后，<strong>需要一小段时间处理，而盘片又在不停地旋转</strong></p>
<p>因此，如果 2、3 号扇区相邻着排列，则读完 2 号扇区后无法连续不断地读入 3 号扇区</p>
<p>必须等盘片继续旋转，3 号扇区再次划过磁头，才能完成扇区读入</p>
<p>结论：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的 “延迟时间”</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220204055975.png" alt="image-20230220204055975" /></p>
<hr />
<h2 id="交替编号"><a class="anchor" href="#交替编号">#</a> 交替编号</h2>
<p>若采用交替编号的策略，即让<strong>逻辑上相邻的扇区在物理上有一定的间隔</strong>，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p>
<p>如下所示，若读取 2 号扇区并处理该数据内容，磁头此时在 6 号扇区，可以直接划过 3 号扇区读取数据，而不需要再等盘片旋转一轮</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220205131736.png" alt="image-20230220205131736" /></p>
<h2 id="磁盘地址结构的设计"><a class="anchor" href="#磁盘地址结构的设计">#</a> 磁盘地址结构的设计</h2>
<p>思考：为什么？</p>
<p>磁盘的物理地址是（柱面号，盘面号，扇区号）</p>
<p>而不是（盘面号，柱面号，扇区号)</p>
<hr />
<p>假设某磁盘有 8 个柱面 / 磁道（假设最内侧柱面 / 磁道号为 0 ） , 4 个盘面，8 个扇区。</p>
<ul>
<li>则可用 3 个二进制位表示柱面，2 个二进制位表示盘面，3 个二进制位表示扇区。</li>
</ul>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>若物理地址结构是（盘面号，柱面号，扇区号）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}若物理地址结构是（盘面号，柱面号，扇区号）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">若物理地址结构是（盘面号，柱面号，扇区号）</span></span></span></span>，且需要连续读取物理地址（00, 000, 000) ~ (00,001,111）的扇区:</p>
<p>（00, 000, 000） ~ （00, 000,111）转两圈可读完</p>
<ul>
<li>第一圈读取 0，1，2，3</li>
<li>第二圈读取 4，5，6，7</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220210011435.png" alt="image-20230220210011435" /></p>
<p>之后再读取物理地址相邻的区域，即<br />
（00, 001, 000） ~ （00, 001, 111 ），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>需要启动磁头臂，将磁头移动到下一个磁道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}需要启动磁头臂，将磁头移动到下一个磁道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">需要启动磁头臂，将磁头移动到下一个磁道</span></span></span></span></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220210209013.png" alt="image-20230220210209013" /></p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>若物理地址结构是（柱面号，盘面号，扇区号）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}若物理地址结构是（柱面号，盘面号，扇区号）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">若物理地址结构是（柱面号，盘面号，扇区号）</span></span></span></span>，且需要连续读取物理地址（00, 000, 000) ~ (00,001,111）的扇区:</p>
<p>（000, 00, 000） ~ （000, 00,111）由盘面 0 的磁头读入数据</p>
<ul>
<li>转两圈可读完</li>
</ul>
<p>之后再读取物理地址相邻的区域，即</p>
<p>（000, 01, 000） ~ （000, 01, 111 ），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>由于柱面号</mtext><mi mathvariant="normal">/</mi><mtext>磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">由于柱面号</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</span></span></span></span></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220210507760.png" alt="image-20230220210507760" /></p>
<hr />
<p>柱面号放中间，读地址连续时，就需要移动磁头</p>
<p>盘面号放中间，读地址连续十，就不需要移动磁头，因为柱面是一致的</p>
<p>重点是：<strong>减少读取连续地址的时间</strong></p>
<p>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p>
<hr />
<h2 id="错位命名"><a class="anchor" href="#错位命名">#</a> 错位命名</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220211457425.png" alt="image-20230220211457425" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220211709472.png" alt="image-20230220211709472" /></p>
<h2 id="整体框架-10"><a class="anchor" href="#整体框架-10">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220211930892.png" alt="image-20230220211930892" /></p>
<h1 id="磁盘的管理"><a class="anchor" href="#磁盘的管理">#</a> 磁盘的管理</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220213229353.png" alt="image-20230220213229353" /></p>
<h2 id="磁盘初始化"><a class="anchor" href="#磁盘初始化">#</a> 磁盘初始化</h2>
<p><code>Step 1</code> ：进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>低级格式化（物理格式化）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}低级格式化（物理格式化）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">低级格式化（物理格式化）</span></span></span></span>，将磁盘的各个磁道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>划分为扇区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}划分为扇区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">划分为扇区</span></span></span></span>。一个扇区通常可分为头、数据区域（如 512 B 大小)、尾 三个部分组成。</p>
<ul>
<li>一个数据块指向下一个数据块的指针其实就可以保存在尾部部分</li>
</ul>
<p>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、 <code>CRC</code>  循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220213702380.png" alt="image-20230220213702380" /></p>
<hr />
<p><code>Step 2</code> ：将<strong>磁盘分区</strong>，每个分区由若干柱面组成（即分为我们熟悉的 C 盘、D 盘、E 盘)</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220214858136.png" alt="image-20230220214858136" /></p>
<hr />
<p>Step 3：进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑格式化</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑格式化</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑格式化</span></span></span></span>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)</p>
<hr />
<h2 id="引导块"><a class="anchor" href="#引导块">#</a> 引导块</h2>
<p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>初始化程序（自举程序）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}初始化程序（自举程序）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">初始化程序（自举程序）</span></span></span></span>完成的</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220215018228.png" alt="image-20230220215018228" /></p>
<hr />
<p>初始化程序程序（自举程序）放在  <code>ROM</code>  中存在什么问题？</p>
<p>万一需要更新自举程序，将会很不方便，因为  <code>ROM</code>  中的数据无法更改。如何解决呢？</p>
<p><strong>完整的自举程序放在磁盘的启动块（即引导块 / 启动分区）上，启动块位于磁盘的固定位置。</strong></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220220238195.png" alt="image-20230220220238195" /></p>
<p>自举程序的更新会很方便</p>
<p>拥有启动分区的磁盘称为<em>启动磁盘</em>或<em>系统磁盘</em>（C: 盘）</p>
<hr />
<h2 id="坏块的管理"><a class="anchor" href="#坏块的管理">#</a> 坏块的管理</h2>
<p>坏了、无法正常使用的扇区就是 “坏块”。</p>
<p>这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它</p>
<hr />
<p>对于 <code>简单的磁盘</code> ，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在  <code>FAT</code>  表上标明。（在这种方式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>坏块对操作系统不透明</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}坏块对操作系统不透明</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">坏块对操作系统不透明</span></span></span></span>)</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220220658294.png" alt="image-20230220220658294" /></p>
<p>对于 <code>复杂的磁盘</code> ，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个<strong>坏块链表</strong>。</p>
<p>在磁盘出厂前进行<strong>低级格式化（物理格式化）时就将坏块链进行初始化</strong>。</p>
<p>会保留一些 “<strong>备用扇区</strong>”，用于替换坏块。这种方案称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>扇区备用</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}扇区备用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">扇区备用</span></span></span></span>。且这种处理方式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>坏块对操作系统透明</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}坏块对操作系统透明</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">坏块对操作系统透明</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220221002254.png" alt="image-20230220221002254" /></p>
<h2 id="整体框架-11"><a class="anchor" href="#整体框架-11">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230220221202154.png" alt="image-20230220221202154" /></p>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-06-02 17:16:46" itemprop="dateModified" datetime="2023-06-02T17:16:46+08:00">2023-06-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.png" alt="htired 微信支付"/><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.png" alt="htired 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>htired：</strong>htired<i class="ic i-at"><em>@</em></i>何必要叹气呢？</li><li class="link"><strong>本文链接：</strong><a href="https://www.htired.top/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="4、文件管理">https://www.htired.top/2023/06/02/os/4、文件管理/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/02/os/3%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;htired&#x2F;MyPic&#x2F;blob&#x2F;main&#x2F;img&#x2F;6c1bc1deb312449195a8c6a802e916c1.jpg?raw&#x3D;true" title="3、内存管理"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>操作系统</span><h3>3、内存管理</h3></a></div><div class="item right"><a href="/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;htired&#x2F;MyPic&#x2F;blob&#x2F;main&#x2F;img&#x2F;792a4b6934fc491b81342206e3192e59.png?raw&#x3D;true" title="5、设备管理"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>操作系统</span><h3>5、设备管理</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text"> 初识文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.1.</span> <span class="toc-text"> 回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text"> 文件的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text"> 无结构文件 &#x2F; 有结构文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.4.</span> <span class="toc-text"> 文件之间应该怎样组织起来？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%AF%A5%E5%90%91%E4%B8%8A%E6%8F%90%E4%BE%9B%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text"> 操作系统应该向上提供哪些功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E7%9C%8B%E6%96%87%E4%BB%B6%E5%BA%94%E5%A6%82%E4%BD%95%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A4%96%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text"> 从上往下看，文件应如何存放在外存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.7.</span> <span class="toc-text"> 其他需要由操作系统实现的文件管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">1.8.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text"> 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text"> 无结构文件（流式文件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> 有结构文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 顺序文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 索引文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 索引顺序文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 索引顺序文件（检索效率分析）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.5.</span> <span class="toc-text"> 多级索引顺序文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-2"><span class="toc-number">2.3.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">3.</span> <span class="toc-text"> 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text"> 文件控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AF%B9%E7%9B%AE%E5%BD%95%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text"> 需要对目录进行哪些操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text"> 单级目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text"> 两级目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text"> 多级目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text"> 无环图目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9fcb-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.7.</span> <span class="toc-text"> 索引节点（FCB 的改进）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-3"><span class="toc-number">3.8.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E9%9D%9E%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 文件的物理结构（文件分配方式）（对非空闲磁盘块的管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9D%97-%E7%A3%81%E7%9B%98%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text"> 文件块、磁盘块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.2.</span> <span class="toc-text"> 连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text"> 链接分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 隐式链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%9D%97%E5%8F%B7%E5%88%B0%E7%89%A9%E7%90%86%E5%9D%97%E5%8F%B7%E7%9A%84%E8%BD%AC%E5%8F%98"><span class="toc-number">4.3.1.1.</span> <span class="toc-text"> 如何实现文件的逻辑块号到物理块号的转变？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.3.1.2.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5fat"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 显示链接（FAT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%9D%97%E5%8F%B7%E5%88%B0%E7%89%A9%E7%90%86%E5%9D%97%E5%8F%B7%E7%9A%84%E8%BD%AC%E5%8F%98-2"><span class="toc-number">4.3.2.1.</span> <span class="toc-text"> 如何实现文件的逻辑块号到物理块号的转变？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.3.2.2.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">4.4.</span> <span class="toc-text"> 索引分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%9D%97%E5%8F%B7%E5%88%B0%E7%89%A9%E7%90%86%E5%9D%97%E5%8F%B7%E7%9A%84%E8%BD%AC%E5%8F%98-3"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 如何实现文件的逻辑块号到物理块号的转变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 链接方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 多层索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 混合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">4.4.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">4.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E5%AF%B9%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text"> 文件存储空间管理（对空闲磁盘块管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text"> 存储空间的划分与初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text"> 空闲表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text"> 空闲链表法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%9B%98%E5%9D%97%E9%93%BE"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 空闲盘块链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%9B%98%E5%8C%BA%E9%93%BE"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 空闲盘区链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text"> 位示图法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text"> 成组链接法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-4"><span class="toc-number">5.5.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text"> 文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text"> 创建文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text"> 删除文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text"> 打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text"> 关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text"> 读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text"> 写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-5"><span class="toc-number">6.7.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">7.</span> <span class="toc-text"> 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">7.1.</span> <span class="toc-text"> 基于索引节点的共享方式（硬链接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">7.2.</span> <span class="toc-text"> 基于符号链的共享方式（软链接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-6"><span class="toc-number">7.3.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.</span> <span class="toc-text"> 文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.1.</span> <span class="toc-text"> 口令保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.2.</span> <span class="toc-text"> 加密保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE%E7%B2%BE%E7%AE%80%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%A1%A8"><span class="toc-number">8.3.</span> <span class="toc-text"> 控制访问（(精简) 访问控制表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-7"><span class="toc-number">8.4.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">9.</span> <span class="toc-text"> 文件系统的层次结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text"> 磁盘的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98-%E7%A3%81%E9%81%93-%E6%89%87%E5%8C%BA"><span class="toc-number">10.1.</span> <span class="toc-text"> 磁盘、磁道、扇区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">10.2.</span> <span class="toc-text"> 如何在磁盘中读 &#x2F; 写数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%98%E9%9D%A2-%E6%9F%B1%E9%9D%A2"><span class="toc-number">10.3.</span> <span class="toc-text"> 盘面、柱面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">10.4.</span> <span class="toc-text"> 磁盘的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-8"><span class="toc-number">10.5.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text"> 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%9B%98%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.</span> <span class="toc-text"> 一次盘读 &#x2F; 写操作需要的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95fcfs"><span class="toc-number">11.2.</span> <span class="toc-text"> 先来先服务算法（FCFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88sstf"><span class="toc-number">11.3.</span> <span class="toc-text"> 最短寻找时间优先（SSTF）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95scan"><span class="toc-number">11.4.</span> <span class="toc-text"> 扫描 (电梯) 算法（SCAN）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">11.5.</span> <span class="toc-text"> LOCK 调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95c-scan"><span class="toc-number">11.6.</span> <span class="toc-text"> 循环扫描算法（C-SCAN）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-look-%E7%AE%97%E6%B3%95"><span class="toc-number">11.7.</span> <span class="toc-text"> C-LOOK 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-9"><span class="toc-number">11.8.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text"> 减少磁盘延迟时间的办法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-number">12.1.</span> <span class="toc-text"> 交替编号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">12.2.</span> <span class="toc-text"> 磁盘地址结构的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D"><span class="toc-number">12.3.</span> <span class="toc-text"> 错位命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-10"><span class="toc-number">12.4.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text"> 磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">13.1.</span> <span class="toc-text"> 磁盘初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">13.2.</span> <span class="toc-text"> 引导块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">13.3.</span> <span class="toc-text"> 坏块的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-11"><span class="toc-number">13.4.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/2023/06/02/os/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" rel="bookmark" title="1、操作系统概述">1、操作系统概述</a></li><li ><a href="/2023/06/02/os/2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="bookmark" title="2、进程管理">2、进程管理</a></li><li ><a href="/2023/06/02/os/3%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="3、内存管理">3、内存管理</a></li><li  class="active"><a href="/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="bookmark" title="4、文件管理">4、文件管理</a></li><li ><a href="/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="bookmark" title="5、设备管理">5、设备管理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="htired" src="/assets/avatar.jpg"/><p class="name" itemprop="name">htired</p><div class="description" itemprop="description">送君南浦，伤如之何？</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">40</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/yourname" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/collect/" rel="section"><i class="ic i-shoucang"></i>收藏</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/02/os/3%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/06/08/algorithm/%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0/">拼接最大数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/15/algorithm/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/">按列翻转得到最大值等行数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/06/08/algorithm/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/">去除重复字母</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/23/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF/">单调栈模板</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于操作系统">操作系统</a></div><span><a href="/2023/06/02/os/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">1、操作系统概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/09/algorithm/%E6%8E%A8%E7%AE%B1%E5%AD%90/">推箱子</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于操作系统">操作系统</a></div><span><a href="/2023/06/02/os/2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">2、进程管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/07/algorithm/%E6%95%B0%E4%BD%8D-dp-%E6%A8%A1%E6%9D%BF-%E8%87%B3%E5%B0%91%E6%9C%89-1-%E4%BD%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">数位 dp 模板 至少有 1 位重复的数字</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/06/03/algorithm/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%EF%BC%8C%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B0%86%E5%AD%90%E6%95%B0%E7%BB%84%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/">乘法逆元，费马小定理， 并查集， 动态规划-将子数组重新排序得到同一个二叉搜索树的方案数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/31/algorithm/%E7%9F%A9%E9%98%B5%E4%B8%AD%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E6%95%B0/">矩阵中严格递增的单元格数</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">htired @ Htired Love</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">666k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">10:05</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2023/06/02/os/4、文件管理/`,
        favicon: {
        show: `好久不见`,
        hide: `顺其自然`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.11" type="module" fetchpriority="high" defer></script></body></html>