<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="何必要叹气呢？" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="何必要叹气呢？" type="application/atom+xml"><link rel="alternate" type="application/json" title="何必要叹气呢？" href="https://www.htired.top/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.11"><link rel="modulepreload" href="/js/chunk-6AROBX2M.js"></link><link rel="modulepreload" href="/js/chunk-CDFWGKAZ.js"></link><link rel="modulepreload" href="/js/chunk-NGTPZFEZ.js"></link><link rel="modulepreload" href="/js/chunk-T5KHDXD7.js"></link><link rel="modulepreload" href="/js/chunk-UCNSAKJE.js"></link><link rel="modulepreload" href="/js/chunk-WIQECBEN.js"></link><link rel="modulepreload" href="/js/comments-YMZC2DEK.js"></link><link rel="modulepreload" href="/js/copy-tex-5ZQCB5LC.js"></link><link rel="modulepreload" href="/js/index.esm-UQTDDMFT.js"></link><link rel="modulepreload" href="/js/post-GXBO3POO.js"></link><link rel="modulepreload" href="/js/quicklink-Q3LCUN34.js"></link><link rel="modulepreload" href="/js/search-HYBAVWN7.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="modulepreload" href="/js/waline-2AUA5EA7.js"></link><link rel="stylesheet" href="/css/comments-SJZAII77.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="stylesheet" href="/css/siteInit.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="stylesheet" href="/css/waline-ZFRMIHOE.css" media="none" onload="this.media&#x3D;&#39;all&#39;"></link><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/6c1bc1deb312449195a8c6a802e916c1.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/4fc551ee880a11ebb6edd017c2d2eca2.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/792a4b6934fc491b81342206e3192e59.png?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/t1.png?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/81d1da7e1ba142629967fea196c73e0e.jpg?raw=true" as="image" fetchpriority="high"><link rel="preload" href="https://github.com/htired/MyPic/blob/main/img/a47a423f9d1c42f8895c53c72f27ff87.jpg?raw=true" as="image" fetchpriority="high"><meta name="description" content="送君南浦，伤如之何？"/><link rel="canonical" href="https://www.htired.top/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"><title>5、设备管理</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">5、设备管理</h1><div class="meta"><span class="item" title="创建时间：2023-06-02 16:00:04"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-06-02T16:00:04+08:00">2023-06-02</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>23k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>21 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Htired Love</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/6c1bc1deb312449195a8c6a802e916c1.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/4fc551ee880a11ebb6edd017c2d2eca2.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/792a4b6934fc491b81342206e3192e59.png?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/t1.png?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/81d1da7e1ba142629967fea196c73e0e.jpg?raw=true&quot;);"></li><li class="item" style="background-image: url(&quot;https://github.com/htired/MyPic/blob/main/img/a47a423f9d1c42f8895c53c72f27ff87.jpg?raw=true&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/os/" itemprop="item" rel="index" title="分类于操作系统"><span itemprop="name">操作系统<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.htired.top/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="htired"/><meta itemprop="description" content="路还很长，这不是最终的结果, 送君南浦，伤如之何？"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="何必要叹气呢？"/></span><div class="body md" itemprop="articleBody"><p><strong>操作系统对外部硬件的设备管理</strong></p>
<h1 id="io-设备的基本概念与分类"><a class="anchor" href="#io-设备的基本概念与分类">#</a> I/O 设备的基本概念与分类</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221230915562.png" alt="image-20230221230915562" /></p>
<h2 id="什么是-io-设备"><a class="anchor" href="#什么是-io-设备">#</a> 什么是 I/O 设备</h2>
<p>“I/O” 就是 “输入 / 输出”（Input/Output）</p>
<p><code>I/O</code>  设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231118977.png" alt="image-20230221231118977" /></p>
<hr />
<p><code>UNIX</code>  系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231250529.png" alt="image-20230221231250529" /></p>
<h2 id="按使用特性分类"><a class="anchor" href="#按使用特性分类">#</a> 按使用特性分类</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231420741.png" alt="image-20230221231420741" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231424858.png" alt="image-20230221231424858" /></p>
<hr />
<h2 id="按传输速率分类"><a class="anchor" href="#按传输速率分类">#</a> 按传输速率分类</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231513131.png" alt="image-20230221231513131" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221231515433.png" alt="image-20230221231515433" /></p>
<h2 id="按信息交换的单元分类"><a class="anchor" href="#按信息交换的单元分类">#</a> 按信息交换的单元分类</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221232006907.png" alt="image-20230221232006907" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221232009054.png" alt="image-20230221232009054" /></p>
<hr />
<h2 id="整体框架"><a class="anchor" href="#整体框架">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221232905773.png" alt="image-20230221232905773" /></p>
<hr />
<h1 id="io-控制器"><a class="anchor" href="#io-控制器">#</a> I/O 控制器</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221233053098.png" alt="image-20230221233053098" /></p>
<h2 id="io-设备的机械部件"><a class="anchor" href="#io-设备的机械部件">#</a> I/O 设备的机械部件</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221233232337.png" alt="image-20230221233232337" /></p>
<p><code>I/O</code>  设备的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>机械部件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}机械部件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">机械部件</span></span></span></span>主要用来执行具体  <code>l/O</code>  操作。</p>
<ul>
<li>如我们看得见摸得着的鼠标 / 键盘的按钮；显示器的 LED 屏；移动硬盘的磁臂、磁盘盘面。</li>
</ul>
<p><code>I/O</code>  设备的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>电子部件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}电子部件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">电子部件</span></span></span></span>通常是一块插入主板扩充槽的印刷电路板。</p>
<hr />
<h2 id="io-设备的电子部件io-控制器"><a class="anchor" href="#io-设备的电子部件io-控制器">#</a> I/O 设备的电子部件（I/O 控制器）</h2>
<p><code>CPU</code>  无法直接控制  <code>I/O</code>  设备的机械部件，因此  <code>I/O</code>  设备还要有一个电子部件作为  <code>CPU</code>  和  <code>I/O</code>  设备机械部件之间的 “中介”，用于实现  <code>CPU</code>  对设备的控制。</p>
<p>这个电子部件就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}I/O 控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">控制器</span></span></span></span>，又称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备控制器</span></span></span></span>。</p>
<p><code>CPU</code>  可控制  <code>I/O</code>  控制器，又由  <code>I/O</code>  控制器来控制设备的机械部件。</p>
<h2 id="io-控制器的功能"><a class="anchor" href="#io-控制器的功能">#</a> I/O 控制器的功能</h2>
<p>① 接受和识别  <code>CPU</code>  发出的命令</p>
<p>如  <code>CPU</code>  发来的 read/write 命令， <code>I/O</code>  控制器中会有相应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制寄存器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制寄存器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制寄存器</span></span></span></span>存放命令和参数</p>
<p>② 向  <code>CPU</code>  报告设备的状态</p>
<p><code>I/O</code>  控制器中会有相应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>状态寄存器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}状态寄存器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">状态寄存器</span></span></span></span>。用于记录  <code>I/O</code>  设备的当前状态。</p>
<ul>
<li>如：1 表示空闲， 0 表示忙碌</li>
</ul>
<p>③ 数据交换</p>
<p><code>I/O</code>  控制器中会设置相应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据寄存器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据寄存器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">数据寄存器</span></span></span></span>。</p>
<ul>
<li>输出时，数据寄存器用于暂存  <code>CPU</code>  发来的数据，之后再由控制器传送设备。</li>
<li>输入时，数据寄存器用于暂存设备发来的数据，之后  <code>CPU</code>  从数据寄存器中取走数据。</li>
</ul>
<p>④ 地址识别</p>
<p>类似于内存的地址，<strong>为了区分设备控制器中的各个寄存器</strong>，也需要给各个寄存器设置一个特定的 “地址”。</p>
<p><code>I/O</code>  控制器通过  <code>CPU</code>  提供的 “地址” 来判断  <code>CPU</code>  要读 / 写的是哪个寄存器</p>
<hr />
<h2 id="io-控制器的组成"><a class="anchor" href="#io-控制器的组成">#</a> I/O 控制器的组成</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221234752599.png" alt="image-20230221234752599" /></p>
<p>小细节：</p>
<p>① 一个 I/O 可能会对应多个设备；</p>
<p>② 数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制 / 状态寄存器对应一个具体的设备），且<strong>这些寄存器都要有相应的地址</strong>，才能方便  <code>CPU</code>  操作。</p>
<ul>
<li>有的计算机会让这些寄存器占用内存地址的一部分，称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>内存映像</mtext><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}内存映像 I/O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">内存映像</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span></span></span></span>；</li>
<li>另一些计算机则采用  <code>I/O</code>  专用地址，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>寄存器独立编址</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}寄存器独立编址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">寄存器独立编址</span></span></span></span>。</li>
</ul>
<h2 id="内存映像-io-与-寄存器独立编址"><a class="anchor" href="#内存映像-io-与-寄存器独立编址">#</a> 内存映像 I/O 与 寄存器独立编址</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230221235443075.png" alt="image-20230221235443075" /></p>
<h2 id="整体框架-2"><a class="anchor" href="#整体框架-2">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230222000150951.png" alt="image-20230222000150951" /></p>
<h1 id="io-控制方式"><a class="anchor" href="#io-控制方式">#</a> I/O 控制方式</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228205610272.png" alt="image-20230228205610272" /></p>
<p>即：用什么样的方式来控制  <code>I/O</code>  设备的数据读 / 写</p>
<p>需要注意的问题:</p>
<ol>
<li>完成一次读 / 写操作的流程；</li>
<li><code>CPU</code>  干预的频率；</li>
<li>数据传送的单位；</li>
<li>数据的流向；</li>
<li>主要缺点和主要优点。</li>
</ol>
<hr />
<h2 id="程序直接控制方式"><a class="anchor" href="#程序直接控制方式">#</a> 程序直接控制方式</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>K</mi><mi>e</mi><mi>y</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext>：轮询</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}Key word：轮询</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">Key</span><span class="mord mathnormal" style="margin-right:0.02691em;color:red;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">or</span><span class="mord mathnormal" style="color:red;">d</span><span class="mord cjk_fallback" style="color:red;">：轮询</span></span></span></span></p>
<p>① 完成一次读 / 写操作的流程（以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>读操作</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}读操作</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">读操作</span></span></span></span>为例）</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228220356488.png" alt="image-20230228220356488" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228220901015.png" alt="image-20230228220901015" /></p>
<hr />
<p>②  <code>CPU</code>  干预的频率</p>
<p>很频繁， <code>I/O</code>  操作开始之前、完成之后需要  <code>CPU</code>  介入，并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在等待</mtext><mi mathvariant="normal">‘</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>完成的过程中</mtext><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>需要不断地轮询检查</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在等待 `l/O` 完成的过程中 `CPU` 需要不断地轮询检查</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">在等待</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">完成的过程中</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">需要不断地轮询检查</span></span></span></span></p>
<hr />
<p>③ 数据传送的单位</p>
<hr />
<p>④ 数据的流向</p>
<p>读操作（数据输入）：I/O 设备 -&gt; CPU（<strong>指的是 CPU 的寄存器</strong>） -&gt; 内存</p>
<p>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</p>
<p>每个字的读 / 写都需要 CPU 的帮助</p>
<hr />
<p>⑤ 主要缺点和主要优点</p>
<p>优点：实现简单。在读 / 写指令之后，加上实现循环检查的一系列指令即可</p>
<ul>
<li>因此才称为 “程序直接控制方式”</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点：</mtext><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>和</mtext><mi mathvariant="normal">‘</mi><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>设备只能串行工作，</mtext><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>需要一直轮询检查，长期处于“忙等”状态</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点：`CPU` 和 `I/O` 设备只能串行工作，`CPU` 需要一直轮询检查，长期处于“忙等”状态</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">缺点：</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">设备只能串行工作，</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">需要一直轮询检查，长期处于</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">忙等</span><span class="mord" style="color:red;">”</span><span class="mord cjk_fallback" style="color:red;">状态</span></span></span></span>， <code>CPU</code>  利用率低。</p>
<hr />
<h2 id="中断驱动方式"><a class="anchor" href="#中断驱动方式">#</a> 中断驱动方式</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>K</mi><mi>e</mi><mi>y</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext>：中断</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}Key word：中断</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">Key</span><span class="mord mathnormal" style="margin-right:0.02691em;color:red;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">or</span><span class="mord mathnormal" style="color:red;">d</span><span class="mord cjk_fallback" style="color:red;">：中断</span></span></span></span></p>
<p>引入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>中断机制</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}中断机制</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">中断机制</span></span></span></span>。由于  <code>I/O</code>  设备速度很慢，因此在  <code>CPU</code>  发出读 / 写命令后，可<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>将等待</mtext><mi mathvariant="normal">‘</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>的进程阻塞</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}将等待 `l/O` 的进程阻塞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">将等待</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">的进程阻塞</span></span></span></span>，先切换到别的进程执行。当  <code>I/O</code>  完成后，控制器会向  <code>CPU</code>  发出一个中断信号， <code>CPU</code>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>检测到中断信号后</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}检测到中断信号后</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">检测到中断信号后</span></span></span></span>，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中， <code>CPU</code>  从  <code>I/O</code>  控制器读<strong>一个字</strong>的数据传送到  <code>CPU</code>  寄存器，再写入主存。接着，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>恢复等待</mtext><mi mathvariant="normal">‘</mi><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>的进程（或其他进程）的运行环境，然后继续执行</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}`CPU` 恢复等待 `I/O` 的进程（或其他进程）的运行环境，然后继续执行</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">恢复等待</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">的进程（或其他进程）的运行环境，然后继续执行</span></span></span></span>。</p>
<ul>
<li>也可以选择不回复它，让它在就绪队列中继续等待，先执行别的进程</li>
<li>若存储字长 32 位的话，1 个字等于 4 字节</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228222144531.png" alt="image-20230228222144531" /></p>
<p>注意:</p>
<p>①  <code>CPU</code>  会在每个指令周期的末尾检查中断；<br />
② 中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。</p>
<hr />
<p>②  <code>CPU</code>  干预的频率</p>
<p>每次  <code>I/O</code>  操作开始之前、完成之后需要  <code>CPU</code>  介入。<br />
等待  <code>I/O</code>  完成的过程中  <code>CPU</code>  可以切换到别的进程执行。</p>
<p>③ 数据传送的单位</p>
<p>每次读 / 写一个字</p>
<p>④ 数据的流向</p>
<p>读操作（数据输入）：I/O 设备 -&gt; CPU（<strong>指的是 CPU 的寄存器</strong>） -&gt; 内存</p>
<p>写操作（数据输出）：内存 -&gt; CPU -&gt; I/O 设备</p>
<p>⑤ 主要缺点和主要优点</p>
<p>优点：与 “程序直接控制方式” 相比，在 “中断驱动方式” 中， <code>I/O</code>  控制器会通过中断信号主动报告  <code>I/O</code>  已完成， <code>CPU</code>  不再需要不停地轮询。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>和</mtext><mi mathvariant="normal">‘</mi><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>设备可并行工作</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}`CPU` 和 `I/O` 设备可并行工作</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">设备可并行工作</span></span></span></span>， <code>CPU</code>  利用率得到明显提升。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>：<strong>每个字</strong>在  <code>I/O</code>  设备与内存之间的传输，都需要经过  <code>CPU</code>  。而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>频繁的中断处理会消耗较多的</mtext><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>时间</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}频繁的中断处理会消耗较多的 `CPU` 时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">频繁的中断处理会消耗较多的</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">时间</span></span></span></span>。</p>
<hr />
<h2 id="dma-方式"><a class="anchor" href="#dma-方式">#</a> DMA 方式</h2>
<p>与 “中断驱动方式” 相比，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi mathvariant="normal">‘</mi><mi>D</mi><mi>M</mi><mi>A</mi><mi mathvariant="normal">‘</mi><mtext>方式</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}`DMA` 方式</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord mathnormal" style="color:red;">A</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">方式</span></span></span></span>（Direct Memory Access，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>直接存储器存取</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}直接存储器存取</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">直接存储器存取</span></span></span></span>。主要用于块设备的  <code>I/O</code>  控制）有这样几个改进:</p>
<p>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据的传送单位是“块”</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}数据的传送单位是“块”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">数据的传送单位是</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">块</span><span class="mord" style="color:red;">”</span></span></span></span>。不再是一个字、一个字的传送；</p>
<p>② 数据的流向是<strong>从设备直接放入内存，或者从内存直接到设备</strong>。不再需要  <code>CPU</code>  作为 “快递小哥”。</p>
<p>③ 仅在传送一个或多个数据块的开始和结束时，才需要  <code>CPU</code>  干预。</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228223141458.png" alt="image-20230228223141458" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228223718028.png" alt="image-20230228223718028" /></p>
<p><code>DR</code>  （Data Register，数据寄存器）∶暂存从设备到内存，或从内存到设备的数据。</p>
<p><code>MAR</code> （Memory Address Register，内存地址寄存器)∶</p>
<ul>
<li>在输入时， <code>MAR</code>  表示数据应放到内存中的什么位置；</li>
<li>输出时  <code>MAR</code>  表示要输出的数据放在内存中的什么位置。</li>
</ul>
<p><code>DC</code> （Data Counter，数据计数器）：表示剩余要读 / 写的字节数。</p>
<p><code>CR</code>  （Command Register，命令 / 状态寄存器)∶用于存放  <code>CPU</code>  发来的  <code>I/O</code>  命令，或设备的状态信息。</p>
<hr />
<p>其实  <code>DMA</code>  控制器在读入数据的过程中，也是一个字一个字读入的，每次读入的一个字放在  <code>DR</code>  中，再从  <code>DR</code>  写入到内存当中</p>
<hr />
<p>②  <code>CPU</code>  干预的频率</p>
<p>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 千预。</p>
<p>③ 数据传送的单位</p>
<p>每次读 / 写<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>一个或多个块（注意：每次读写的只能是连续的多个块</mtext><mo separator="true">,</mo><mtext>且这些块读入内存后在内存中也必须是连续的</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}一个或多个块（注意：每次读写的只能是连续的多个块,且这些块读入内存后在内存中也必须是连续的)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">一个或多个块（注意：每次读写的只能是连续的多个块</span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback" style="color:red;">且这些块读入内存后在内存中也必须是连续的</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
<ul>
<li>若采用离散的方式的话，同样需要  <code>CPU</code>  发送多条  <code>I/O</code>  指令</li>
</ul>
<p>④ 数据的流向（不再需要经过 CPU）</p>
<p>读操作（数据输入）： <code>l/O</code>  设备 -&gt; 内存</p>
<p>写操作（数据输出）：内存 -&gt;  <code>I/O</code>  设备</p>
<p>⑤ 主要缺点和主要优点</p>
<p>优点：数据传输以 “块” 为单位， <code>CPU</code>  介入频率进一步降低。数据的传输不再需要先经过  <code>CPU</code>  再写入内存，数据传输效率进一步增加。 <code>CPU</code>  和  <code>I/O</code>  设备的并行性得到提升。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缺点</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缺点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缺点</span></span></span></span>： <code>CPU</code>  每发出一条  <code>I/O</code>  指令，只能读 / 写一个或多个连续的数据块。</p>
<p>如果要读 / 写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时， <code>CPU</code>  要分别发出多条  <code>I/O</code>  指令，进行多次中断处理才能完成。</p>
<hr />
<h2 id="通道控制方式"><a class="anchor" href="#通道控制方式">#</a> 通道控制方式</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道</span></span></span></span>：一种<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>硬件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}硬件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">硬件</span></span></span></span>，可以理解为是 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>弱鸡版的</mtext><mi>C</mi><mi>P</mi><mi>U</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}弱鸡版的 CPU</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">弱鸡版的</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span></span></span></span>”。通道可以识别并执行一系列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道指令</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道指令</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道指令</span></span></span></span></p>
<p>与  <code>CPU</code>  相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与  <code>CPU</code>  共享内存</p>
<ul>
<li>
<p>通道 = 弱鸡版  <code>CPU</code></p>
</li>
<li>
<p>通道程序 = 任务清单</p>
</li>
</ul>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228224826849.png" alt="image-20230228224826849" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228224909553.png" alt="image-20230228224909553" /></p>
<p>②  <code>CPU</code>  干预的频率</p>
<p>极低，通道会根据  <code>CPU</code>  的指示执行相应的通道程序，只有完成一组数据块的读 / 写后才需要发出中断信号，请求 <code>CPU</code>  干预。</p>
<p>③ 数据传送的单位</p>
<p>每次读 / 写<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>一组数据块</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}一组数据块</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">一组数据块</span></span></span></span></p>
<p>④ 数据的流向（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在通道的控制下进行</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在通道的控制下进行</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在通道的控制下进行</span></span></span></span>）</p>
<p>读操作（数据输入）： <code>l/O</code>  设备 -&gt; 内存</p>
<p>写操作（数据输出）：内存 -&gt;  <code>I/O</code>  设备</p>
<p>⑤ 主要缺点和主要优点</p>
<p>缺点：实现复杂，需要专门的通道硬件支持</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>优点：</mtext><mi mathvariant="normal">‘</mi><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">‘</mi><mtext>、通道、</mtext><mi mathvariant="normal">‘</mi><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mi mathvariant="normal">‘</mi><mtext>设备可并行工作，资源利用率很高</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}优点：`CPU`、通道、`I/O` 设备可并行工作，资源利用率很高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">优点：</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CP</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">、通道、</span><span class="mord" style="color:red;">‘</span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord" style="color:red;">‘</span><span class="mord cjk_fallback" style="color:red;">设备可并行工作，资源利用率很高</span></span></span></span>。</p>
<hr />
<h2 id="整体框架-3"><a class="anchor" href="#整体框架-3">#</a> 整体框架</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228231326011.png" alt="image-20230228231326011" /></p>
<h1 id="i-0-软件层次结构"><a class="anchor" href="#i-0-软件层次结构">#</a> I-0 软件层次结构</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228233253369.png" alt="image-20230228233253369" /></p>
<h2 id="用户层软件"><a class="anchor" href="#用户层软件">#</a> 用户层软件</h2>
<p>用户层软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>实现了与用户交互的接口</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}实现了与用户交互的接口</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">实现了与用户交互的接口</span></span></span></span>，用户可直接使用该层提供的、与  <code>I/O</code>  操作相关的库函数对设备进行操作</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228233508504.png" alt="image-20230228233508504" /></p>
<hr />
<h2 id="设备独立性软件逻辑设备表lut"><a class="anchor" href="#设备独立性软件逻辑设备表lut">#</a> 设备独立性软件，逻辑设备表（LUT）</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备独立性软件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备独立性软件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备独立性软件</span></span></span></span>，又称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备无关性软件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备无关性软件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备无关性软件</span></span></span></span>。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<p>主要实现的功能：</p>
<p>① 向上层提供统一的调用接口（如  <code>read/write</code>  系统调用）</p>
<p>② 设备的保护</p>
<p>原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，<strong>同理，对设备的访问权限也不一样。</strong></p>
<p>③ 差错处理</p>
<p>设备独立性软件需要对一些设备的错误进行处理</p>
<p>④ 设备的分配与回收</p>
<p>⑤ 数据缓冲区管理</p>
<p>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
<p>⑥ <strong>建立逻辑设备名到物理设备名的映射关系</strong>；根据设备类型选择调用相应的驱动程序</p>
<p>用户或用户层软件发出  <code>I/O</code>  操作相关系统调用的系统调用时，需要指明此次要操作的  <code>I/O</code>  设备的逻辑设备名</p>
<ul>
<li>eg：去学校打印店打印时，需要选择打印机 1 / 打印机 2 / 打印机 3 ，其实这些都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑设备名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑设备名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑设备名</span></span></span></span></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备独立性软件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备独立性软件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备独立性软件</span></span></span></span>需要通过 “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑设备表（</mtext><mi>L</mi><mi>U</mi><mi>T</mi><mtext>，</mtext><mi>L</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑设备表（LUT，Logical UnitTable）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑设备表（</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord mathnormal" style="color:red;">L</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">g</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">c</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">U</span><span class="mord mathnormal" style="color:red;">ni</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">tT</span><span class="mord mathnormal" style="color:red;">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>” 来确定逻辑设备对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理设备</span></span></span></span>，并找到该设备对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备驱动程序</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备驱动程序</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备驱动程序</span></span></span></span></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234247127.png" alt="image-20230228234247127" /></p>
<p>操作系统系统可以采用两种方式管理 $\color {red} 逻辑设备表（LUT) $:</p>
<p>第一种方式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>整个系统只设置一张</mtext><mi>L</mi><mi>U</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}整个系统只设置一张 LUT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">整个系统只设置一张</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span></span></span></span>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p>
<p>第二种方式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>为每个用户设置一张</mtext><mi>L</mi><mi>U</mi><mi>T</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}为每个用户设置一张 LUT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">为每个用户设置一张</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span></span></span></span>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。</p>
<ul>
<li>系统会在用户登录时为其建立一个用户管理进程，而  <code>LUT</code>  就存放在用户管理进程的  <code>PCB</code>  中。</li>
</ul>
<p>类似于单级目录和两级目录</p>
<hr />
<h2 id="不同类型的-io-设备需要有不同的驱动程序处理设备驱动程序"><a class="anchor" href="#不同类型的-io-设备需要有不同的驱动程序处理设备驱动程序">#</a> 不同类型的 I/O 设备需要有不同的驱动程序处理？（设备驱动程序）</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234624484.png" alt="image-20230228234624484" /></p>
<p>各式各样的设备，外形不同，其内部的电子部件（ <code>I/O</code>  控制器）也有可能不同</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234743751.png" alt="image-20230228234743751" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234827726.png" alt="image-20230228234827726" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234921244.png" alt="image-20230228234921244" /></p>
<p><strong>就是  <code>I/O</code>  控制器可能不相同</strong></p>
<p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序， <code>CPU</code>  执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p>
<ul>
<li>例如：鼠标或者键盘，当  <code>usb</code>  插入到电脑的时候，右下角会有正在安装驱动程序的提示</li>
</ul>
<hr />
<h2 id="设备驱动程序"><a class="anchor" href="#设备驱动程序">#</a> 设备驱动程序</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228235203660.png" alt="image-20230228235203660" /></p>
<p>注：驱动程序一般会以一个独立进程的方式存在</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228234247127.png" alt="image-20230228234247127" /></p>
<h2 id="中断处理程序"><a class="anchor" href="#中断处理程序">#</a> 中断处理程序</h2>
<p>当  <code>I/O</code>  任务完成时， <code>l/O</code>  控制器会发送一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>中断信号</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}中断信号</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">中断信号</span></span></span></span>，系统会<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>根据中断信号类型</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}根据中断信号类型</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">根据中断信号类型</span></span></span></span>找到相应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>中断处理程序</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}中断处理程序</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">中断处理程序</span></span></span></span>并执行。中断处理程序的处理流程如下:</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230228235721872.png" alt="image-20230228235721872" /></p>
<h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230301000131129.png" alt="image-20230301000131129" /></p>
<p>理解并记住  <code>I/O</code>  软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>各个层次之间的顺序</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}各个层次之间的顺序</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">各个层次之间的顺序</span></span></span></span>，要能够推理判断某个处理应该是在哪个层次完成的</p>
<p>最常考的是设备独立性软件、设备驱动程序这两层。</p>
<p>只需理解一个特点即可：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的</mtext><mo separator="true">;</mo><mtext>没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的;没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback" style="color:red;">直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的</span><span class="mpunct" style="color:red;">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback" style="color:red;">没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</span></span></span></span></p>
<h1 id="i-o-核心子系统"><a class="anchor" href="#i-o-核心子系统">#</a> I-O 核心子系统</h1>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318174102667.png" alt="image-20230318174102667" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318174241557.png" alt="image-20230318174241557" /></p>
<p>注：假脱机技术（ <code>SPOOLing</code>  技术）需要请求 “磁盘设备” 的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。但是 408 大纲又将假脱机技术归为 “I/O 核心子系统” 的功能，因此考试时还是以大纲为准。</p>
<hr />
<h2 id="io-调度"><a class="anchor" href="#io-调度">#</a> I/O 调度</h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>调度：用某种算法确定一个好的顺序来处理各个</mtext><mi>l</mi><mi mathvariant="normal">/</mi><mi>O</mi><mtext>请求。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}I/O 调度：用某种算法确定一个好的顺序来处理各个 l/O 请求。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;color:red;">I</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">调度：用某种算法确定一个好的顺序来处理各个</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord" style="color:red;">/</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mord cjk_fallback" style="color:red;">请求。</span></span></span></span></p>
<p>如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN 算法、C-SCAN 算法、LOOK 算法 C-LOOK 算法）。当多个磁盘  <code>I/O</code>  请求到来时，用某种调度算法确定满足  <code>l/O</code>  请求的顺序。</p>
<p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定  <code>l/O</code>  调度顺序。</p>
<hr />
<h2 id="设备保护"><a class="anchor" href="#设备保护">#</a> 设备保护</h2>
<p>操作系统需要实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>文件保护功能</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}文件保护功能</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">文件保护功能</span></span></span></span>，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）。</p>
<p>在  <code>UNIX</code>  系统中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备被看做是一种特殊的文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备被看做是一种特殊的文件</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备被看做是一种特殊的文件</span></span></span></span>，每个设备也会有对应的  <code>FCB</code> 。</p>
<ul>
<li>当用户请求访问某个设备时，系统根据  <code>FCB</code>  中记录的信息来判断该用户是否有相应的访问权限，以此实现 “设备保护” 的功能。（参考 “<a href="#4.8%E3%80%81%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4">4.8、文件保护</a> ” 小节)</li>
</ul>
<hr />
<h2 id="假脱机技术spooling-技术"><a class="anchor" href="#假脱机技术spooling-技术">#</a> 假脱机技术（SPOOLing 技术）</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318174949686.png" alt="image-20230318174949686" /></p>
<hr />
<h3 id="什么是脱机技术"><a class="anchor" href="#什么是脱机技术">#</a> 什么是脱机技术</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175050072.png" alt="image-20230318175050072" /></p>
<p>手工操作阶段：主机直接从  <code>l/O</code>  设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备</p>
<hr />
<p>批处理阶段引入了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>脱机输入</mtext><mi mathvariant="normal">/</mi><mtext>输出技术</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}脱机输入/输出技术</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">脱机输入</span><span class="mord" style="color:red;">/</span><span class="mord cjk_fallback" style="color:red;">输出技术</span></span></span></span>（用磁带完成）:</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175250570.png" alt="image-20230318175250570" /></p>
<p>Tips：为什么称为 “脱机”―― <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>脱离主机的控制</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}脱离主机的控制</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">脱离主机的控制</span></span></span></span>进行的输入 / 输出操作。</p>
<p>引入脱机技术后，缓解了  <code>CPU</code>  与慢速  <code>I/O</code>  设备的速度矛盾。</p>
<ul>
<li>另一方面，即使  <code>CPU</code>  在忙碌，也可以提前将数据输入到磁带；</li>
<li>即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。</li>
</ul>
<hr />
<h3 id="假脱机技术"><a class="anchor" href="#假脱机技术">#</a> 假脱机技术</h3>
<p>“假脱机技术”，又称 “SPOOLing 技术” 是用软件的方式模拟脱机技术。 <code>SPOOLing</code>  系统的组成如下:</p>
<hr />
<h4 id="输入井和输出井"><a class="anchor" href="#输入井和输出井">#</a> 输入井和输出井</h4>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175602243.png" alt="image-20230318175602243" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175659256.png" alt="image-20230318175659256" /></p>
<hr />
<h4 id="输入进程与输出进程"><a class="anchor" href="#输入进程与输出进程">#</a> 输入进程与输出进程</h4>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175736968.png" alt="image-20230318175736968" /></p>
<p>要实现  <code>SPOOLing</code>  技术，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>必须要有多道程序技术的支持</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}必须要有多道程序技术的支持</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">必须要有多道程序技术的支持</span></span></span></span>。系统会建立 “输入进程” 和 “输出进程”。</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318175919640.png" alt="image-20230318175919640" /></p>
<hr />
<h4 id="输入输出缓冲区"><a class="anchor" href="#输入输出缓冲区">#</a> 输入 / 输出缓冲区</h4>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318180149434.png" alt="image-20230318180149434" /></p>
<hr />
<h3 id="共享打印机原理分析"><a class="anchor" href="#共享打印机原理分析">#</a> 共享打印机原理分析</h3>
<p>独占式设备――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>只允许各个进程串行使用的设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}只允许各个进程串行使用的设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">只允许各个进程串行使用的设备</span></span></span></span>。一段时间内只能满足一个进程的请求。</p>
<p>共享设备――<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>允许多个进程“同时”使用的设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}允许多个进程“同时”使用的设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">允许多个进程</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">同时</span><span class="mord" style="color:red;">”</span><span class="mord cjk_fallback" style="color:red;">使用的设备</span></span></span></span>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318180708641.png" alt="image-20230318180708641" /></p>
<p>独占式设备的例子：若进程 1 正在使用打印机，则进程 2 请求使用打印机时必然阻塞等待</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318181050755.png" alt="image-20230318181050755" /></p>
<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事:</p>
<p>(1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</p>
<p>(2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上（打印任务队列）。<br />
当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p>
<hr />
<p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<hr />
<p><code>SPOOLing</code>  技术可以把一台物理设备<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>虚拟</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}虚拟</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">虚拟</span></span></span></span>成逻辑上的多台设备，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>可将独占式设备改造成共享设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}可将独占式设备改造成共享设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">可将独占式设备改造成共享设备</span></span></span></span>。</p>
<h3 id="整体框架-4"><a class="anchor" href="#整体框架-4">#</a> 整体框架</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318181530354.png" alt="image-20230318181530354" /></p>
<h2 id="设备的分配与回收"><a class="anchor" href="#设备的分配与回收">#</a> 设备的分配与回收</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318181729558.png" alt="image-20230318181729558" /></p>
<h3 id="设备分配时应考虑的因素"><a class="anchor" href="#设备分配时应考虑的因素">#</a> 设备分配时应考虑的因素</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318181817129.png" alt="image-20230318181817129" /></p>
<p>设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p>
<hr />
<p><strong>设备的固有属性</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>独占设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}独占设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">独占设备</span></span></span></span> ―― 一个时段只能分配给一个进程（如打印机）</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>共享设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}共享设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">共享设备</span></span></span></span> ―― 可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>虚拟设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}虚拟设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">虚拟设备</span></span></span></span> ―― 采用  <code>SPOOLing</code>  技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用</p>
<ul>
<li>如采用 <code>SPOOLing</code>  技术实现的共享打印机</li>
</ul>
<hr />
<p><strong>设备的分配算法</strong></p>
<p>先来先服务</p>
<p>优先级高者优先</p>
<p>短任务优先</p>
<hr />
<p><strong>设备分配中的安全性</strong></p>
<p>从进程运行的安全性上考虑，设备分配有两种方式:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>安全分配方式</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}安全分配方式</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">安全分配方式</span></span></span></span>：为进程分配一个设备后就将进程阻塞，本次  <code>I/O</code>  完成后才将进程唤醒。</p>
<ul>
<li>eg：考虑进程请求打印机打印输出的例子</li>
</ul>
<p>一个时段内每个进程只能使用一个设备</p>
<p>优点：破坏了 “请求和保持” 条件，不会死锁<br />
缺点：对于一个进程来说， <code>CPU</code>  和  <code>I/O</code>  设备只能串行工作</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不安全分配方式</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不安全分配方式</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不安全分配方式</span></span></span></span>：进程发出  <code>I/O</code>  请求后，系统为其分配  <code>I/O</code>  设备，进程可继续执行，之后还可以发出新的  <code>l/O</code>  请求。只有某个  <code>l/O</code>  请求得不到满足时才将进程阻塞。</p>
<p>一个进程可以同时使用多个设备</p>
<p>优点：进程的计算任务和  <code>I/O</code>  任务可以并行处理，使进程迅速推进</p>
<p>缺点：有可能发生死锁（死锁避免、死锁的检测和解除)</p>
<hr />
<h3 id="静态分配和动态分配"><a class="anchor" href="#静态分配和动态分配">#</a> 静态分配和动态分配</h3>
<p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</p>
<ul>
<li>破坏了 “请求和保持” 条件，不会死锁</li>
</ul>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<ul>
<li>可用银行家算法或者结合资源分配图对死锁的检测和解除</li>
</ul>
<hr />
<h3 id="设备分配管理中的数据结构"><a class="anchor" href="#设备分配管理中的数据结构">#</a> 设备分配管理中的数据结构</h3>
<p>“设备、控制器、通道” 之间的关系:</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318183344989.png" alt="image-20230318183344989" /></p>
<p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p>
<hr />
<h4 id="设备控制表dct"><a class="anchor" href="#设备控制表dct">#</a> 设备控制表（DCT）</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备控制表（</mtext><mi>D</mi><mi>C</mi><mi>T</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备控制表（DCT）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备控制表（</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CT</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>：系统为每个设备配置一张  <code>DCT</code> ，用于记录设备情况</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318183658426.png" alt="image-20230318183658426" /></p>
<p>注：“进程管理” 章节中曾经提到过 “系统会根据阻塞原因不同，将进程  <code>PCB</code>  挂到不同的阻塞队列中”</p>
<ul>
<li>若某进程需要等待  <code>I/O</code>  设备的分配，但是这个  <code>I/O</code>  设备没法给该进程分配资源，会将该进程就会挂到这个  <code>I/O</code>  设备的设备控制表所指向的设备队列的队尾</li>
</ul>
<hr />
<h4 id="控制器控制表coct"><a class="anchor" href="#控制器控制表coct">#</a> 控制器控制表（COCT）</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器控制表（</mtext><mi>C</mi><mi>O</mi><mi>C</mi><mi>T</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器控制表（COCT）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器控制表（</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">COCT</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>：每个设备控制器都会对应一张  <code>COCT</code> 。操作系统根据  <code>COCT</code>  的信息对控制器进行操作和管理。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318184214735.png" alt="image-20230318184214735" /></p>
<h4 id="通道控制表chct"><a class="anchor" href="#通道控制表chct">#</a> 通道控制表（CHCT）</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道控制表（</mtext><mi>C</mi><mi>H</mi><mi>C</mi><mi>T</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道控制表（CHCT）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道控制表（</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;color:red;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">CT</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>：每个通道都会对应一张  <code>CHCT</code> 。操作系统根据  <code>CHCT</code>  的信息对通道进行操作和管理。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318184417573.png" alt="image-20230318184417573" /></p>
<h4 id="系统设备表sdt"><a class="anchor" href="#系统设备表sdt">#</a> 系统设备表（SDT）</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>系统设备表（</mtext><mi>S</mi><mi>D</mi><mi>T</mi><mtext>）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}系统设备表（SDT）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">系统设备表（</span><span class="mord mathnormal" style="margin-right:0.05764em;color:red;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">）</span></span></span></span>：记录了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>系统中全部设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}系统中全部设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">系统中全部设备</span></span></span></span>的情况，每个设备对应一个表目。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318184508904.png" alt="image-20230318184508904" /></p>
<hr />
<h3 id="设备分配的步骤"><a class="anchor" href="#设备分配的步骤">#</a> 设备分配的步骤</h3>
<p>① 根据进程请求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>物理设备名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}物理设备名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">物理设备名</span></span></span></span>查找  <code>SDT</code> （注：物理设备名是进程请求分配设备时提供的参数)</p>
<p>② 根据  <code>SDT</code>  找到  <code>DCT</code>  ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备</span></span></span></span>分配给进程。</p>
<p>③ 根据  <code>DCT</code>  找到  <code>COCT</code>  ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器</span></span></span></span>分配给进程。</p>
<p>④ 根据  <code>COCT</code>  找到  <code>CHCT</code> ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道</span></span></span></span>分配给进程。</p>
<hr />
<p>缺点:</p>
<p>① 用户编程时必须使用 “物理设备名”，底层细节对用户不透明，不方便编程</p>
<p>② 若换了一个物理设备，则程序无法运行</p>
<p>③ 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p>
<ul>
<li>若有 3 台打印机，若此时进程请求的是第 1 台打印机，虽然其他 2 台打印机是空闲的，但是只要第 1 台打印机是忙碌的，进程依然是要阻塞等待</li>
</ul>
<hr />
<h3 id="设备分配步骤的改进逻辑设备表"><a class="anchor" href="#设备分配步骤的改进逻辑设备表">#</a> 设备分配步骤的改进（逻辑设备表）</h3>
<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>
<hr />
<p>① 根据进程请求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑设备名</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑设备名</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑设备名</span></span></span></span>查找  <code>SDT</code> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注</mtext><mo>:</mo><mtext>用户编程时提供的逻辑设备名其实就是“设备类型”</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注:用户编程时提供的逻辑设备名其实就是 “设备类型”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel" style="color:red;">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">用户编程时提供的逻辑设备名其实就是</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">设备类型</span><span class="mord" style="color:red;">”</span></span></span></span> ）</p>
<p>② 查找  <code>SDT</code> ，找到用户进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>指定类型的、并且空闲</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}指定类型的、并且空闲</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">指定类型的、并且空闲</span></span></span></span>的设备，将其分配给该进程。操作系统<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在逻辑设备表（</mtext><mi>L</mi><mi>U</mi><mi>T</mi><mtext>）中新增一个表项</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在逻辑设备表（LUT）中新增一个表项</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在逻辑设备表（</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">）中新增一个表项</span></span></span></span>。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318185553757.png" alt="image-20230318185553757" /></p>
<p>② 根据  <code>SDT</code>  找到  <code>DCT</code>  ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>设备</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}设备</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">设备</span></span></span></span>分配给进程。</p>
<p>③ 根据  <code>DCT</code>  找到  <code>COCT</code>  ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>控制器</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}控制器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">控制器</span></span></span></span>分配给进程。</p>
<p>④ 根据  <code>COCT</code>  找到  <code>CHCT</code> ，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道</span></span></span></span>忙碌则将进程  <code>PCB</code>  挂到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道等待队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道等待队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道等待队列</span></span></span></span>中，不忙碌则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>通道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}通道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">通道</span></span></span></span>分配给进程。</p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑设备表（</mtext><mi>L</mi><mi>U</mi><mi>T</mi><mtext>）建立了逻辑设备名与物理设备名之间的映射关系。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑设备表（</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">）建立了逻辑设备名与物理设备名之间的映射关系。</span></span></span></span></p>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在  <code>LUT</code>  中增加相应表项。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过</mtext><mi>L</mi><mi>U</mi><mi>T</mi><mtext>表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过 LUT 表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">LU</span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mord cjk_fallback" style="color:red;">表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</span></span></span></span></p>
<ul>
<li>类似于缓存</li>
</ul>
<hr />
<p>逻辑设备表的设置问题:</p>
<p>整个系统只有一张  <code>LUT</code> ：各用户所用的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>逻辑设备名不允许重复</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}逻辑设备名不允许重复</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">逻辑设备名不允许重复</span></span></span></span>，适用于单用户操作系统</p>
<p>每个用户一张  <code>LUT</code> ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不同用户的逻辑设备名可重复</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}不同用户的逻辑设备名可重复</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">不同用户的逻辑设备名可重复</span></span></span></span>，适用于多用户操作系统</p>
<h3 id="整体框架-5"><a class="anchor" href="#整体框架-5">#</a> 整体框架</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318191503132.png" alt="image-20230318191503132" /></p>
<h2 id="缓冲区管理"><a class="anchor" href="#缓冲区管理">#</a> 缓冲区管理</h2>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318192447770.png" alt="image-20230318192447770" /></p>
<h3 id="什么是缓冲区有什么作用"><a class="anchor" href="#什么是缓冲区有什么作用">#</a> 什么是缓冲区？有什么作用？</h3>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<p>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>硬件作为缓冲区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}硬件作为缓冲区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">硬件作为缓冲区</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>成本较高</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}成本较高</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">成本较高</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>容量也较小</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}容量也较小</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">容量也较小</span></span></span></span>，一般仅用在对速度要求非常高的场合</p>
<ul>
<li>如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本</li>
</ul>
<p>一般情况下，更多的是利用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>内存作为缓冲区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}内存作为缓冲区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">内存作为缓冲区</span></span></span></span>，“设备独立性软件” 的缓冲区管理就是要组织管理好这些缓冲区</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318193018994.png" alt="image-20230318193018994" /></p>
<hr />
<p>如下所示：只有缓冲区中的数据充满了或者被取走为空后，  <code>CPU</code>  才会介入来处理中断</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318192747361.png" alt="image-20230318192747361" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318192817102.png" alt="image-20230318192817102" /></p>
<hr />
<h3 id="单缓冲"><a class="anchor" href="#单缓冲">#</a> 单缓冲</h3>
<p>假设某用户进程请求某种块设备读入若干块的数据。若采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>单缓冲</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}单缓冲</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">单缓冲</span></span></span></span>的策略，操作系统会<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在主存中为其分配一个缓冲区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在主存中为其分配一个缓冲区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在主存中为其分配一个缓冲区</span></span></span></span>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</span></span></span></span></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318195506997.png" alt="image-20230318195506997" /></p>
<p>常考题型：计算每处理一块数据平均需要多久？</p>
<p>技巧：假定一个初始状态，<strong>分析下次到达相同状态需要多少时间</strong>，这就是处理一块数据平均所需时间。</p>
<p>在 “单缓冲” 题型中，可以假设初始状态为工作区满，缓冲区空。</p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318195814934.png" alt="image-20230318195814934" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318200003587.png" alt="image-20230318200003587" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318200023751.png" alt="image-20230318200023751" /></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>结论：采用单缓冲策略，处理一块数据平均耗时</mtext><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>+</mo><mi>M</mi></mstyle></mrow><annotation encoding="application/x-tex">\color{red}结论：采用单缓冲策略，处理一块数据平均耗时 Max(C, T) + M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">结论：采用单缓冲策略，处理一块数据平均耗时</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">x</span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mclose" style="color:red;">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span></span></span></span></p>
<h3 id="双缓冲"><a class="anchor" href="#双缓冲">#</a> 双缓冲</h3>
<p>假设某用户进程请求某种块设备读入若干块的数据。若采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>双缓冲</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}双缓冲</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">双缓冲</span></span></span></span>的策略，操作系统会<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>在主存中为其分配两个缓冲区</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}在主存中为其分配两个缓冲区</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">在主存中为其分配两个缓冲区</span></span></span></span>（若题目中没有特别说明，一个缓冲区的大小就是一个块)</p>
<p>双缓冲题目中，假设初始状态为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>工作区空，其中一个缓冲区满，另一个缓冲区空</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}工作区空，其中一个缓冲区满，另一个缓冲区空</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">工作区空，其中一个缓冲区满，另一个缓冲区空</span></span></span></span></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318202253341.png" alt="image-20230318202253341" /></p>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318203743449.png" alt="image-20230318203743449" /></p>
<hr />
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>结论：采用双缓冲策略，处理一块数据平均耗时</mtext><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>C</mi><mo>+</mo><mi>M</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\color{red}结论：采用双缓冲策略，处理一块数据平均耗时 Max(C + M, T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">结论：采用双缓冲策略，处理一块数据平均耗时</span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="color:red;">x</span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.07153em;color:red;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;color:red;">M</span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;color:red;">T</span><span class="mclose" style="color:red;">)</span></span></span></span></p>
<hr />
<h3 id="使用单双缓冲在通信时的区别"><a class="anchor" href="#使用单双缓冲在通信时的区别">#</a> 使用单 / 双缓冲在通信时的区别</h3>
<p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318204027285.png" alt="image-20230318204027285" /></p>
<p>显然，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p>
<ul>
<li>类似于半双工</li>
</ul>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318205551749.png" alt="image-20230318205551749" /></p>
<p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>注：管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}注：管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">注：管道通信中的</span><span class="mord" style="color:red;">“</span><span class="mord cjk_fallback" style="color:red;">管道</span><span class="mord" style="color:red;">”</span><span class="mord cjk_fallback" style="color:red;">其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</span></span></span></span></p>
<ul>
<li>类似于全双工</li>
</ul>
<h3 id="循环缓冲区"><a class="anchor" href="#循环缓冲区">#</a> 循环缓冲区</h3>
<p>将多个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>大小相等</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}大小相等</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">大小相等</span></span></span></span>的缓冲区链接成一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>循环队列</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}循环队列</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">循环队列</span></span></span></span>。</p>
<p>注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318205720022.png" alt="image-20230318205720022" /></p>
<h3 id="缓冲池"><a class="anchor" href="#缓冲池">#</a> 缓冲池</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>缓冲池</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}缓冲池</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">缓冲池</span></span></span></span>由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:</p>
<ul>
<li>用于收容输入数据的工作缓冲区（hin）</li>
<li>用于提取输入数据的工作缓冲区（sin）</li>
<li>用于收容输出数据的工作缓冲区（hout）</li>
<li>用于提取输出数据的工作缓冲区（sout）</li>
</ul>
<hr />
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318211206465.png" alt="image-20230318211206465" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318211345971.png" alt="image-20230318211345971" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318211513276.png" alt="image-20230318211513276" /></p>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318211607495.png" alt="image-20230318211607495" /></p>
<h3 id="整体框架-6"><a class="anchor" href="#整体框架-6">#</a> 整体框架</h3>
<p><img loading="lazy" data-src="https://gitcode.net/qq_67720621/img/-/raw/master/typora-user-images-new/image-20230318211802506.png" alt="image-20230318211802506" /></p>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-06-02 17:16:54" itemprop="dateModified" datetime="2023-06-02T17:16:54+08:00">2023-06-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.png" alt="htired 微信支付"/><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.png" alt="htired 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>htired：</strong>htired<i class="ic i-at"><em>@</em></i>何必要叹气呢？</li><li class="link"><strong>本文链接：</strong><a href="https://www.htired.top/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="5、设备管理">https://www.htired.top/2023/06/02/os/5、设备管理/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;htired&#x2F;MyPic&#x2F;blob&#x2F;main&#x2F;img&#x2F;792a4b6934fc491b81342206e3192e59.png?raw&#x3D;true" title="4、文件管理"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>操作系统</span><h3>4、文件管理</h3></a></div><div class="item right"><a href="/2023/06/03/algorithm/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%EF%BC%8C%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B0%86%E5%AD%90%E6%95%B0%E7%BB%84%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;htired&#x2F;MyPic&#x2F;blob&#x2F;main&#x2F;img&#x2F;a47a423f9d1c42f8895c53c72f27ff87.jpg?raw&#x3D;true" title="乘法逆元，费马小定理， 并查集， 动态规划-将子数组重新排序得到同一个二叉搜索树的方案数"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>算法</span><h3>乘法逆元，费马小定理， 并查集， 动态规划-将子数组重新排序得到同一个二叉搜索树的方案数</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#io-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text"> I&#x2F;O 设备的基本概念与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-io-%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text"> 什么是 I&#x2F;O 设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text"> 按使用特性分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text"> 按传输速率分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8D%95%E5%85%83%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text"> 按信息交换的单元分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">1.5.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> I&#x2F;O 控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E8%AE%BE%E5%A4%87%E7%9A%84%E6%9C%BA%E6%A2%B0%E9%83%A8%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text"> I&#x2F;O 设备的机械部件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E8%AE%BE%E5%A4%87%E7%9A%84%E7%94%B5%E5%AD%90%E9%83%A8%E4%BB%B6io-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text"> I&#x2F;O 设备的电子部件（I&#x2F;O 控制器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.</span> <span class="toc-text"> I&#x2F;O 控制器的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.4.</span> <span class="toc-text"> I&#x2F;O 控制器的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F-io-%E4%B8%8E-%E5%AF%84%E5%AD%98%E5%99%A8%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="toc-number">2.5.</span> <span class="toc-text"> 内存映像 I&#x2F;O 与 寄存器独立编址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-2"><span class="toc-number">2.6.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text"> I&#x2F;O 控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 程序直接控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text"> 中断驱动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dma-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text"> DMA 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text"> 通道控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-3"><span class="toc-number">3.5.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#i-0-%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text"> I-0 软件层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text"> 用户层软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8lut"><span class="toc-number">4.2.</span> <span class="toc-text"> 设备独立性软件，逻辑设备表（LUT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-io-%E8%AE%BE%E5%A4%87%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text"> 不同类型的 I&#x2F;O 设备需要有不同的驱动程序处理？（设备驱动程序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text"> 设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text"> 中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#i-o-%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text"> I-O 核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E8%B0%83%E5%BA%A6"><span class="toc-number">5.1.</span> <span class="toc-text"> I&#x2F;O 调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.2.</span> <span class="toc-text"> 设备保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFspooling-%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text"> 假脱机技术（SPOOLing 技术）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 什么是脱机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 假脱机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%95%E5%92%8C%E8%BE%93%E5%87%BA%E4%BA%95"><span class="toc-number">5.3.2.1.</span> <span class="toc-text"> 输入井和输出井</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%BE%93%E5%87%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.2.2.</span> <span class="toc-text"> 输入进程与输出进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.2.3.</span> <span class="toc-text"> 输入 &#x2F; 输出缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">5.3.3.</span> <span class="toc-text"> 共享打印机原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-4"><span class="toc-number">5.3.4.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">5.4.</span> <span class="toc-text"> 设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%97%B6%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 设备分配时应考虑的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 静态分配和动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 设备分配管理中的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8dct"><span class="toc-number">5.4.3.1.</span> <span class="toc-text"> 设备控制表（DCT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8coct"><span class="toc-number">5.4.3.2.</span> <span class="toc-text"> 控制器控制表（COCT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8chct"><span class="toc-number">5.4.3.3.</span> <span class="toc-text"> 通道控制表（CHCT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8sdt"><span class="toc-number">5.4.3.4.</span> <span class="toc-text"> 系统设备表（SDT）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.4.4.</span> <span class="toc-text"> 设备分配的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%94%B9%E8%BF%9B%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8"><span class="toc-number">5.4.5.</span> <span class="toc-text"> 设备分配步骤的改进（逻辑设备表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-5"><span class="toc-number">5.4.6.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text"> 缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text"> 什么是缓冲区？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">5.5.2.</span> <span class="toc-text"> 单缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">5.5.3.</span> <span class="toc-text"> 双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%8F%8C%E7%BC%93%E5%86%B2%E5%9C%A8%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.4.</span> <span class="toc-text"> 使用单 &#x2F; 双缓冲在通信时的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.5.5.</span> <span class="toc-text"> 循环缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.5.6.</span> <span class="toc-text"> 缓冲池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6-6"><span class="toc-number">5.5.7.</span> <span class="toc-text"> 整体框架</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/2023/06/02/os/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" rel="bookmark" title="1、操作系统概述">1、操作系统概述</a></li><li ><a href="/2023/06/02/os/2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="bookmark" title="2、进程管理">2、进程管理</a></li><li ><a href="/2023/06/02/os/3%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="3、内存管理">3、内存管理</a></li><li ><a href="/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="bookmark" title="4、文件管理">4、文件管理</a></li><li  class="active"><a href="/2023/06/02/os/5%E3%80%81%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="bookmark" title="5、设备管理">5、设备管理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="htired" src="/assets/avatar.jpg"/><p class="name" itemprop="name">htired</p><div class="description" itemprop="description">送君南浦，伤如之何？</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">55</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">40</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/yourname" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/collect/" rel="section"><i class="ic i-shoucang"></i>收藏</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/03/algorithm/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%EF%BC%8C%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B0%86%E5%AD%90%E6%95%B0%E7%BB%84%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/02/os/4%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/06/algorithm/%E5%88%A9%E7%94%A8-gcd-%E7%9A%84%E6%80%A7%E8%B4%A8-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/">利用 gcd 的性质 最大公因数等于 K 的子数组数目</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/29/algorithm/%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%9E%E5%8A%9B%E5%80%BC/">一个小组的最大实力值</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/31/algorithm/%E4%BD%BF%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/">使所有字符相等的最小成本</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/06/01/algorithm/%E6%8C%89%E5%85%AC%E5%9B%A0%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F/">按公因数计算最大组件大小</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/09/algorithm/%E6%8F%90%E5%8F%96%E5%92%92%E6%96%87/">提取咒文</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/23/algorithm/132-%E6%A8%A1%E5%BC%8F/">132 模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/15/algorithm/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/">按列翻转得到最大值等行数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于操作系统">操作系统</a></div><span><a href="/2023/06/02/os/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">1、操作系统概述</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/26/algorithm/c/">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于算法">算法</a></div><span><a href="/2023/05/23/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF/">单调栈模板</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">htired @ Htired Love</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">667k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">10:07</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2023/06/02/os/5、设备管理/`,
        favicon: {
        show: `好久不见`,
        hide: `顺其自然`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.11" type="module" fetchpriority="high" defer></script></body></html>